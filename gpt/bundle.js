/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./gpt/main.ts":
/*!*********************!*\
  !*** ./gpt/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   initUI: () => (/* binding */ initUI),\n/* harmony export */   initWllama: () => (/* binding */ initWllama),\n/* harmony export */   loadModel: () => (/* binding */ loadModel)\n/* harmony export */ });\n/* harmony import */ var _node_modules_wllama_wllama_esm_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/@wllama/wllama/esm/index.js */ \"./node_modules/@wllama/wllama/esm/index.js\");\n// src/main.ts\n\n// Wllama实例\nlet wllamaInstance = null;\n// 配置路径\nconst CONFIG_PATHS = {\n    'single-thread/wllama.wasm': '/gpt/wllama/single-thread/wllama.wasm',\n    'multi-thread/wllama.wasm': '/gpt/wllama/multi-thread/wllama.wasm',\n};\n// 初始化Wllama\nasync function initWllama() {\n    wllamaInstance = new _node_modules_wllama_wllama_esm_index_js__WEBPACK_IMPORTED_MODULE_0__.Wllama(CONFIG_PATHS);\n    wllamaInstance.useMultiThread = true;\n    wllamaInstance.nbThreads = 4;\n    wllamaInstance.useEmbeddings = false;\n    return wllamaInstance;\n}\n// 加载模型\nasync function loadModel(progressCallback) {\n    if (!wllamaInstance) {\n        throw new Error(\"Wllama未初始化\");\n    }\n    await wllamaInstance.loadModelFromHF('mradermacher/DeepSeek-R1-Distill-Qwen-1.5B-Abliterated-dpo-GGUF', 'DeepSeek-R1-Distill-Qwen-1.5B-Abliterated-dpo.Q2_K.gguf', { progressCallback });\n}\n// 生成文本\nasync function generateText(prompt, options = {\n    nPredict: 50,\n    sampling: {\n        temp: 0.5,\n        top_k: 40,\n        top_p: 0.9,\n    }\n}) {\n    if (!wllamaInstance) {\n        throw new Error(\"模型未加载\");\n    }\n    return await wllamaInstance.createCompletion(prompt, options);\n}\n// 初始化UI事件\nfunction initUI() {\n    // 获取DOM元素\n    const loadModelBtn = document.getElementById('loadModel');\n    const generateBtn = document.getElementById('generate');\n    const progressElem = document.getElementById('progress');\n    const inputElem = document.getElementById('inputText');\n    const outputElem = document.getElementById('output');\n    // 检查元素是否存在\n    if (!loadModelBtn || !generateBtn || !progressElem || !inputElem || !outputElem) {\n        console.error(\"找不到必要的DOM元素\");\n        return;\n    }\n    // 加载模型按钮事件\n    loadModelBtn.addEventListener('click', async () => {\n        try {\n            loadModelBtn.disabled = true;\n            progressElem.textContent = '初始化中...';\n            // 初始化Wllama\n            await initWllama();\n            progressElem.textContent = '开始下载模型...';\n            // 加载模型\n            await loadModel(({ loaded, total }) => {\n                const progressPercentage = Math.round((loaded / total) * 100);\n                progressElem.textContent = `下载中... ${progressPercentage}%`;\n            });\n            progressElem.textContent = '模型加载完成！';\n            generateBtn.disabled = false;\n        }\n        catch (error) {\n            progressElem.textContent = `错误: ${error instanceof Error ? error.message : String(error)}`;\n            loadModelBtn.disabled = false;\n            console.error(error);\n        }\n    });\n    // 生成文本按钮事件\n    generateBtn.addEventListener('click', async () => {\n        try {\n            const inputText = inputElem.value.trim();\n            if (!inputText) {\n                outputElem.textContent = '请输入提示文本！';\n                return;\n            }\n            generateBtn.disabled = true;\n            outputElem.textContent = '生成中...';\n            // 生成文本\n            const outputText = await generateText(inputText);\n            outputElem.textContent = outputText;\n        }\n        catch (error) {\n            outputElem.textContent = `错误: ${error instanceof Error ? error.message : String(error)}`;\n            console.error(error);\n        }\n        finally {\n            generateBtn.disabled = false;\n        }\n    });\n}\n// 在DOM加载完成后初始化UI\ndocument.addEventListener('DOMContentLoaded', initWllama);\n\n\n//# sourceURL=webpack://victoryang00.github.io/./gpt/main.ts?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/cache-manager.js":
/*!**********************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/cache-manager.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POLYFILL_ETAG: () => (/* binding */ POLYFILL_ETAG),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@wllama/wllama/esm/utils.js\");\n/* harmony import */ var _workers_code_generated_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./workers-code/generated.js */ \"./node_modules/@wllama/wllama/esm/workers-code/generated.js\");\n\n\nconst PREFIX_METADATA = '__metadata__';\n// To prevent breaking change, we fill etag with a pre-defined value\nconst POLYFILL_ETAG = 'polyfill_for_older_version';\n/**\n * Cache implementation using OPFS (Origin private file system)\n *\n * This class is also responsible for downloading files from the internet.\n */\nclass CacheManager {\n    /**\n     * Convert a given URL into file name in cache.\n     *\n     * Format of the file name: `${hashSHA1(fullURL)}_${fileName}`\n     */\n    async getNameFromURL(url) {\n        return await urlToFileName(url, '');\n    }\n    /**\n     * @deprecated Use `download()` instead\n     *\n     * Write a new file to cache. This will overwrite existing file.\n     *\n     * @param name The file name returned by `getNameFromURL()` or `list()`\n     */\n    async write(name, stream, metadata) {\n        this.writeMetadata(name, metadata); // no need await\n        return await opfsWrite(name, stream);\n    }\n    async download(url, options = {}) {\n        const worker = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)(_workers_code_generated_js__WEBPACK_IMPORTED_MODULE_1__.OPFS_UTILS_WORKER_CODE);\n        let aborted = false;\n        if (options.signal) {\n            aborted = options.signal.aborted;\n            const mSignal = options.signal;\n            mSignal.addEventListener('abort', () => {\n                aborted = true;\n                worker.postMessage({ action: 'download-abort' });\n            });\n            delete options.signal;\n        }\n        const metadataFileName = await urlToFileName(url, PREFIX_METADATA);\n        const filename = await urlToFileName(url, '');\n        return await new Promise((resolve, reject) => {\n            worker.postMessage({\n                action: 'download',\n                url,\n                filename,\n                metadataFileName,\n                options: { headers: options.headers, aborted },\n            });\n            worker.onmessage = (e) => {\n                if (e.data.ok) {\n                    worker.terminate();\n                    resolve();\n                }\n                else if (e.data.err) {\n                    worker.terminate();\n                    reject(e.data.err);\n                }\n                else if (e.data.progress) {\n                    const progress = e.data.progress;\n                    options.progressCallback?.(progress);\n                }\n                else {\n                    // should never happen\n                    reject(new Error('Unknown message from worker'));\n                    console.error('Unknown message from worker', e.data);\n                }\n            };\n        });\n    }\n    /**\n     * Open a file in cache for reading\n     *\n     * @param nameOrURL The file name returned by `getNameFromURL()` or `list()`, or the original URL of the remote file\n     * @returns Blob, or null if file does not exist\n     */\n    async open(nameOrURL) {\n        return await opfsOpen(nameOrURL);\n    }\n    /**\n     * Get the size of a file in stored cache\n     *\n     * NOTE: in case the download is stopped mid-way (i.e. user close browser tab), the file maybe corrupted, size maybe different from `metadata.originalSize`\n     *\n     * @param name The file name returned by `getNameFromURL()` or `list()`\n     * @returns number of bytes, or -1 if file does not exist\n     */\n    async getSize(name) {\n        return await opfsFileSize(name);\n    }\n    /**\n     * Get metadata of a cached file\n     */\n    async getMetadata(name) {\n        const stream = await opfsOpen(name, PREFIX_METADATA);\n        const cachedSize = await this.getSize(name);\n        if (!stream) {\n            return cachedSize > 0\n                ? // files created by older version of wllama doesn't have metadata, we will try to polyfill it\n                    {\n                        etag: POLYFILL_ETAG,\n                        originalSize: cachedSize,\n                        originalURL: '',\n                    }\n                : // if cached file not found, we don't have metadata at all\n                    null;\n        }\n        try {\n            const meta = await new Response(stream).json();\n            return meta;\n        }\n        catch (e) {\n            // worst case: metadata is somehow corrupted, we will re-download the model\n            return null;\n        }\n    }\n    /**\n     * List all files currently in cache\n     */\n    async list() {\n        const cacheDir = await getCacheDir();\n        const result = [];\n        const metadataMap = {};\n        // @ts-ignore\n        for await (let [name, handler] of cacheDir.entries()) {\n            if (handler.kind === 'file' && name.startsWith(PREFIX_METADATA)) {\n                const stream = (await handler.getFile()).stream();\n                const meta = await new Response(stream).json().catch((_) => null);\n                metadataMap[name.replace(PREFIX_METADATA, '')] = meta;\n            }\n        }\n        // @ts-ignore\n        for await (let [name, handler] of cacheDir.entries()) {\n            if (handler.kind === 'file' && !name.startsWith(PREFIX_METADATA)) {\n                result.push({\n                    name,\n                    size: await handler\n                        .getFile()\n                        .then((f) => f.size),\n                    metadata: metadataMap[name] || {\n                        // try to polyfill for old versions\n                        originalSize: (await handler.getFile())\n                            .size,\n                        originalURL: '',\n                        etag: '',\n                    },\n                });\n            }\n        }\n        return result;\n    }\n    /**\n     * Clear all files currently in cache\n     */\n    async clear() {\n        await this.deleteMany(() => true);\n    }\n    /**\n     * Delete a single file in cache\n     *\n     * @param nameOrURL Can be either an URL or a name returned by `getNameFromURL()` or `list()`\n     */\n    async delete(nameOrURL) {\n        const name2 = await this.getNameFromURL(nameOrURL);\n        await this.deleteMany((entry) => entry.name === nameOrURL || entry.name === name2);\n    }\n    /**\n     * Delete multiple files in cache.\n     *\n     * @param predicate A predicate like `array.filter(item => boolean)`\n     */\n    async deleteMany(predicate) {\n        const cacheDir = await getCacheDir();\n        const list = await this.list();\n        for (const item of list) {\n            if (predicate(item)) {\n                cacheDir.removeEntry(item.name);\n            }\n        }\n    }\n    /**\n     * Write the metadata of the file to disk.\n     *\n     * This function is separated from `write()` for compatibility reason. In older version of wllama, there was no metadata for cached file, so when newer version of wllama loads a file created by older version, it will try to polyfill the metadata.\n     */\n    async writeMetadata(name, metadata) {\n        const blob = new Blob([JSON.stringify(metadata)], { type: 'text/plain' });\n        await opfsWrite(name, blob.stream(), PREFIX_METADATA);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CacheManager);\n/**\n * Write to OPFS file from ReadableStream\n */\nasync function opfsWrite(key, stream, prefix = '') {\n    try {\n        const fileName = await urlToFileName(key, prefix);\n        const writable = await opfsWriteViaWorker(fileName);\n        await writable.truncate(0); // clear file content\n        const reader = stream.getReader();\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done)\n                break;\n            await writable.write(value);\n        }\n        await writable.close();\n    }\n    catch (e) {\n        console.error('opfsWrite', e);\n    }\n}\n/**\n * Opens a file in OPFS for reading\n * @returns ReadableStream\n */\nasync function opfsOpen(originalURLOrName, prefix = '') {\n    const getFileHandler = async (fname) => {\n        try {\n            const cacheDir = await getCacheDir();\n            const fileHandler = await cacheDir.getFileHandle(fname);\n            return await fileHandler.getFile();\n        }\n        catch (e) {\n            // TODO: check if exception is NotFoundError\n            return null;\n        }\n    };\n    let handler = await getFileHandler(originalURLOrName);\n    if (handler) {\n        return handler;\n    }\n    // retry if needed\n    const fileName = await urlToFileName(originalURLOrName, prefix);\n    handler = await getFileHandler(fileName);\n    return handler;\n}\n/**\n * Get file size of a file in OPFS\n * @returns number of bytes, or -1 if file does not exist\n */\nasync function opfsFileSize(originalURL, prefix = '') {\n    try {\n        const cacheDir = await getCacheDir();\n        const fileName = await urlToFileName(originalURL, prefix);\n        const fileHandler = await cacheDir.getFileHandle(fileName);\n        const file = await fileHandler.getFile();\n        return file.size;\n    }\n    catch (e) {\n        // TODO: check if exception is NotFoundError\n        return -1;\n    }\n}\nasync function urlToFileName(url, prefix) {\n    const hashBuffer = await crypto.subtle.digest('SHA-1', new TextEncoder().encode(url));\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n    return `${prefix}${hashHex}_${url.split('/').pop()}`;\n}\nasync function getCacheDir() {\n    const opfsRoot = await navigator.storage.getDirectory();\n    const cacheDir = await opfsRoot.getDirectoryHandle('cache', { create: true });\n    return cacheDir;\n}\nasync function opfsWriteViaWorker(fileName) {\n    const worker = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)(_workers_code_generated_js__WEBPACK_IMPORTED_MODULE_1__.OPFS_UTILS_WORKER_CODE);\n    let pResolve;\n    let pReject;\n    worker.onmessage = (e) => {\n        if (e.data.ok)\n            pResolve(null);\n        else if (e.data.err)\n            pReject(e.data.err);\n    };\n    const workerExec = (data) => new Promise((resolve, reject) => {\n        pResolve = resolve;\n        pReject = reject;\n        // TODO @ngxson : Safari mobile doesn't support transferable ArrayBuffer\n        worker.postMessage(data, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isSafariMobile)()\n            ? undefined\n            : {\n                transfer: data.value ? [data.value.buffer] : [],\n            });\n    });\n    await workerExec({ open: fileName });\n    return {\n        truncate: async () => {\n            /* noop */\n        },\n        write: (value) => workerExec({ value }),\n        close: async () => {\n            await workerExec({ done: true });\n            worker.terminate();\n        },\n    };\n}\n//# sourceMappingURL=cache-manager.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/cache-manager.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/glue/glue.js":
/*!******************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/glue/glue.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   glueDeserialize: () => (/* binding */ glueDeserialize),\n/* harmony export */   glueSerialize: () => (/* binding */ glueSerialize)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@wllama/wllama/esm/glue/messages.js\");\n\nconst GLUE_MAGIC = new Uint8Array([71, 76, 85, 69]);\nconst GLUE_DTYPE_NULL = 0;\nconst GLUE_DTYPE_BOOL = 1;\nconst GLUE_DTYPE_INT = 2;\nconst GLUE_DTYPE_FLOAT = 3;\nconst GLUE_DTYPE_STRING = 4;\nconst GLUE_DTYPE_RAW = 5;\nconst GLUE_DTYPE_ARRAY_BOOL = 6;\nconst GLUE_DTYPE_ARRAY_INT = 7;\nconst GLUE_DTYPE_ARRAY_FLOAT = 8;\nconst GLUE_DTYPE_ARRAY_STRING = 9;\nconst GLUE_DTYPE_ARRAY_RAW = 10;\nconst TYPE_MAP = {\n    str: GLUE_DTYPE_STRING,\n    int: GLUE_DTYPE_INT,\n    float: GLUE_DTYPE_FLOAT,\n    bool: GLUE_DTYPE_BOOL,\n    raw: GLUE_DTYPE_RAW,\n    arr_str: GLUE_DTYPE_ARRAY_STRING,\n    arr_int: GLUE_DTYPE_ARRAY_INT,\n    arr_float: GLUE_DTYPE_ARRAY_FLOAT,\n    arr_bool: GLUE_DTYPE_ARRAY_BOOL,\n    arr_raw: GLUE_DTYPE_ARRAY_RAW,\n    null: GLUE_DTYPE_NULL,\n};\nfunction glueDeserialize(buf) {\n    let offset = 0;\n    const view = new DataView(buf.buffer);\n    const readUint32 = () => {\n        const value = view.getUint32(offset, true);\n        offset += 4;\n        return value;\n    };\n    const readInt32 = () => {\n        const value = view.getInt32(offset, true);\n        offset += 4;\n        return value;\n    };\n    const readFloat = () => {\n        const value = view.getFloat32(offset, true);\n        offset += 4;\n        return value;\n    };\n    const readBool = () => {\n        return readUint32() !== 0;\n    };\n    const readString = (customLen) => {\n        const length = customLen ?? readUint32();\n        const value = new TextDecoder().decode(buf.slice(offset, offset + length));\n        offset += length;\n        return value;\n    };\n    const readRaw = () => {\n        const length = readUint32();\n        const value = buf.slice(offset, offset + length);\n        offset += length;\n        return value;\n    };\n    const readArray = (readItem) => {\n        const length = readUint32();\n        const value = new Array(length);\n        for (let i = 0; i < length; i++) {\n            value[i] = readItem();\n        }\n        return value;\n    };\n    const readNull = () => null;\n    const readField = (field) => {\n        switch (field.type) {\n            case 'str':\n                return readString();\n            case 'int':\n                return readInt32();\n            case 'float':\n                return readFloat();\n            case 'bool':\n                return readBool();\n            case 'raw':\n                return readRaw();\n            case 'arr_str':\n                return readArray(readString);\n            case 'arr_int':\n                return readArray(readInt32);\n            case 'arr_float':\n                return readArray(readFloat);\n            case 'arr_bool':\n                return readArray(readBool);\n            case 'arr_raw':\n                return readArray(readRaw);\n            case 'null':\n                return readNull();\n        }\n    };\n    const magicValid = buf[0] === GLUE_MAGIC[0] &&\n        buf[1] === GLUE_MAGIC[1] &&\n        buf[2] === GLUE_MAGIC[2] &&\n        buf[3] === GLUE_MAGIC[3];\n    offset += 4;\n    if (!magicValid) {\n        throw new Error('Invalid magic number');\n    }\n    const version = readUint32();\n    if (version !== _messages_js__WEBPACK_IMPORTED_MODULE_0__.GLUE_VERSION) {\n        throw new Error('Invalid version number');\n    }\n    const name = readString(8);\n    const msgProto = _messages_js__WEBPACK_IMPORTED_MODULE_0__.GLUE_MESSAGE_PROTOTYPES[name];\n    if (!msgProto) {\n        throw new Error(`Unknown message name: ${name}`);\n    }\n    const output = { _name: name };\n    for (const field of msgProto.fields) {\n        const readType = readUint32();\n        if (readType === GLUE_DTYPE_NULL) {\n            if (!field.isNullable) {\n                throw new Error(`${name}: Expect field ${field.name} to be non-nullable`);\n            }\n            output[field.name] = null;\n            continue;\n        }\n        if (readType !== TYPE_MAP[field.type]) {\n            throw new Error(`${name}: Expect field ${field.name} to have type ${field.type}`);\n        }\n        output[field.name] = readField(field);\n    }\n    return output;\n}\nfunction glueSerialize(msg) {\n    const msgProto = _messages_js__WEBPACK_IMPORTED_MODULE_0__.GLUE_MESSAGE_PROTOTYPES[msg._name];\n    if (!msgProto) {\n        throw new Error(`Unknown message name: ${msg._name}`);\n    }\n    const bufs = [];\n    const writeUint32 = (value) => {\n        const buf = new ArrayBuffer(4);\n        new DataView(buf).setUint32(0, value, true);\n        bufs.push(new Uint8Array(buf));\n    };\n    const writeInt32 = (value) => {\n        const buf = new ArrayBuffer(4);\n        new DataView(buf).setInt32(0, value, true);\n        bufs.push(new Uint8Array(buf));\n    };\n    const writeFloat = (value) => {\n        const buf = new ArrayBuffer(4);\n        new DataView(buf).setFloat32(0, value, true);\n        bufs.push(new Uint8Array(buf));\n    };\n    const writeBool = (value) => {\n        writeUint32(value ? 1 : 0);\n    };\n    const writeString = (value) => {\n        const utf8 = new TextEncoder().encode(value);\n        writeUint32(utf8.byteLength);\n        bufs.push(utf8);\n    };\n    const writeRaw = (value) => {\n        writeUint32(value.byteLength);\n        bufs.push(value);\n    };\n    const writeArray = (value, writeItem) => {\n        writeUint32(value.length);\n        for (const item of value) {\n            writeItem(item);\n        }\n    };\n    const writeNull = () => { };\n    //////////////////\n    bufs.push(GLUE_MAGIC);\n    writeUint32(_messages_js__WEBPACK_IMPORTED_MODULE_0__.GLUE_VERSION);\n    {\n        // write proto ID\n        const utf8 = new TextEncoder().encode(msg._name);\n        bufs.push(utf8);\n    }\n    for (const field of msgProto.fields) {\n        const val = msg[field.name];\n        if (!field.isNullable && (val === null || val === undefined)) {\n            throw new Error(`${msg._name}: Expect field ${field.name} to be non-nullable`);\n        }\n        if (val === null || val === undefined) {\n            writeUint32(GLUE_DTYPE_NULL);\n            continue;\n        }\n        writeUint32(TYPE_MAP[field.type]);\n        switch (field.type) {\n            case 'str':\n                writeString(val);\n                break;\n            case 'int':\n                writeInt32(val);\n                break;\n            case 'float':\n                writeFloat(val);\n                break;\n            case 'bool':\n                writeBool(val);\n                break;\n            case 'raw':\n                writeRaw(val);\n                break;\n            case 'arr_str':\n                writeArray(val, writeString);\n                break;\n            case 'arr_int':\n                writeArray(val, writeInt32);\n                break;\n            case 'arr_float':\n                writeArray(val, writeFloat);\n                break;\n            case 'arr_bool':\n                writeArray(val, writeBool);\n                break;\n            case 'arr_raw':\n                writeArray(val, writeRaw);\n                break;\n            case 'null':\n                writeNull();\n                break;\n        }\n    }\n    const totalLength = bufs.reduce((acc, buf) => acc + buf.byteLength, 0);\n    const output = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const buf of bufs) {\n        output.set(buf, offset);\n        offset += buf.byteLength;\n    }\n    return output;\n}\n//# sourceMappingURL=glue.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/glue/glue.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/glue/messages.js":
/*!**********************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/glue/messages.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLUE_MESSAGE_PROTOTYPES: () => (/* binding */ GLUE_MESSAGE_PROTOTYPES),\n/* harmony export */   GLUE_VERSION: () => (/* binding */ GLUE_VERSION)\n/* harmony export */ });\n// This file is generated by cpp/generate_glue_prototype.js\n// Do not edit this file directly\nconst GLUE_VERSION = 1;\nconst GLUE_MESSAGE_PROTOTYPES = {\n    \"erro_evt\": {\n        \"name\": \"erro_evt\",\n        \"structName\": \"glue_msg_error\",\n        \"className\": \"GlueMsgError\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"load_req\": {\n        \"name\": \"load_req\",\n        \"structName\": \"glue_msg_load_req\",\n        \"className\": \"GlueMsgLoadReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_str\",\n                \"name\": \"model_paths\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"n_ctx_auto\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"use_mmap\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"use_mlock\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_gpu_layers\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"seed\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_ctx\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_threads\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"embeddings\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"offload_kqv\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_batch\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_seq_max\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"pooling_type\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"rope_scaling_type\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"rope_freq_base\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"rope_freq_scale\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"yarn_ext_factor\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"yarn_attn_factor\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"yarn_beta_fast\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"yarn_beta_slow\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"yarn_orig_ctx\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"cache_type_k\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"cache_type_v\",\n                \"isNullable\": true\n            }\n        ]\n    },\n    \"load_res\": {\n        \"name\": \"load_res\",\n        \"structName\": \"glue_msg_load_res\",\n        \"className\": \"GlueMsgLoadRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_ctx\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_batch\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_ubatch\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_vocab\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_ctx_train\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_embd\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_layer\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_str\",\n                \"name\": \"metadata_key\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_str\",\n                \"name\": \"metadata_val\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"token_bos\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"token_eos\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"token_eot\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"list_tokens_eog\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"add_bos_token\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"add_eos_token\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"has_encoder\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"token_decoder_start\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"opti_req\": {\n        \"name\": \"opti_req\",\n        \"structName\": \"glue_msg_set_options_req\",\n        \"className\": \"GlueMsgSetOptionsReq\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"embeddings\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"opti_res\": {\n        \"name\": \"opti_res\",\n        \"structName\": \"glue_msg_set_options_res\",\n        \"className\": \"GlueMsgSetOptionsRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sint_req\": {\n        \"name\": \"sint_req\",\n        \"structName\": \"glue_msg_sampling_init_req\",\n        \"className\": \"GlueMsgSamplingInitReq\",\n        \"fields\": [\n            {\n                \"type\": \"int\",\n                \"name\": \"mirostat\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"mirostat_tau\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"mirostat_eta\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"temp\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"top_p\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"top_k\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"penalty_last_n\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"penalty_repeat\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"penalty_freq\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"penalty_present\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"dynatemp_range\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"dynatemp_exponent\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"arr_str\",\n                \"name\": \"samplers_sequence\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"grammar\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_prev\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_probs\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"min_p\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"typical_p\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"typ_p\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"logit_bias_toks\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"arr_float\",\n                \"name\": \"logit_bias_vals\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": true\n            }\n        ]\n    },\n    \"sint_res\": {\n        \"name\": \"sint_res\",\n        \"structName\": \"glue_msg_sampling_init_res\",\n        \"className\": \"GlueMsgSamplingInitRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"gvoc_req\": {\n        \"name\": \"gvoc_req\",\n        \"structName\": \"glue_msg_get_vocab_req\",\n        \"className\": \"GlueMsgGetVocabReq\",\n        \"fields\": []\n    },\n    \"gvoc_res\": {\n        \"name\": \"gvoc_res\",\n        \"structName\": \"glue_msg_get_vocab_res\",\n        \"className\": \"GlueMsgGetVocabRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_raw\",\n                \"name\": \"vocab\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"lkup_req\": {\n        \"name\": \"lkup_req\",\n        \"structName\": \"glue_msg_lookup_token_req\",\n        \"className\": \"GlueMsgLookupTokenReq\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"piece\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"lkup_res\": {\n        \"name\": \"lkup_res\",\n        \"structName\": \"glue_msg_lookup_token_res\",\n        \"className\": \"GlueMsgLookupTokenRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"token\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"tokn_req\": {\n        \"name\": \"tokn_req\",\n        \"structName\": \"glue_msg_tokenize_req\",\n        \"className\": \"GlueMsgTokenizeReq\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"text\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"special\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"tokn_res\": {\n        \"name\": \"tokn_res\",\n        \"structName\": \"glue_msg_tokenize_res\",\n        \"className\": \"GlueMsgTokenizeRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"dtkn_req\": {\n        \"name\": \"dtkn_req\",\n        \"structName\": \"glue_msg_detokenize_req\",\n        \"className\": \"GlueMsgDetokenizeReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"dtkn_res\": {\n        \"name\": \"dtkn_res\",\n        \"structName\": \"glue_msg_detokenize_res\",\n        \"className\": \"GlueMsgDetokenizeRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"raw\",\n                \"name\": \"buffer\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"deco_req\": {\n        \"name\": \"deco_req\",\n        \"structName\": \"glue_msg_decode_req\",\n        \"className\": \"GlueMsgDecodeReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"skip_logits\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"deco_res\": {\n        \"name\": \"deco_res\",\n        \"structName\": \"glue_msg_decode_res\",\n        \"className\": \"GlueMsgDecodeRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_past\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"enco_req\": {\n        \"name\": \"enco_req\",\n        \"structName\": \"glue_msg_encode_req\",\n        \"className\": \"GlueMsgEncodeReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"enco_res\": {\n        \"name\": \"enco_res\",\n        \"structName\": \"glue_msg_encode_res\",\n        \"className\": \"GlueMsgEncodeRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_past\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"ssam_req\": {\n        \"name\": \"ssam_req\",\n        \"structName\": \"glue_msg_sampling_sample_req\",\n        \"className\": \"GlueMsgSamplingSampleReq\",\n        \"fields\": []\n    },\n    \"ssam_res\": {\n        \"name\": \"ssam_res\",\n        \"structName\": \"glue_msg_sampling_sample_res\",\n        \"className\": \"GlueMsgSamplingSampleRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"raw\",\n                \"name\": \"piece\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"token\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sacc_req\": {\n        \"name\": \"sacc_req\",\n        \"structName\": \"glue_msg_sampling_accept_req\",\n        \"className\": \"GlueMsgSamplingAcceptReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sacc_res\": {\n        \"name\": \"sacc_res\",\n        \"structName\": \"glue_msg_sampling_accept_res\",\n        \"className\": \"GlueMsgSamplingAcceptRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"glog_req\": {\n        \"name\": \"glog_req\",\n        \"structName\": \"glue_msg_get_logits_req\",\n        \"className\": \"GlueMsgGetLogitsReq\",\n        \"fields\": [\n            {\n                \"type\": \"int\",\n                \"name\": \"top_k\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"glog_res\": {\n        \"name\": \"glog_res\",\n        \"structName\": \"glue_msg_get_logits_res\",\n        \"className\": \"GlueMsgGetLogitsRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_float\",\n                \"name\": \"probs\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"gemb_req\": {\n        \"name\": \"gemb_req\",\n        \"structName\": \"glue_msg_get_embeddings_req\",\n        \"className\": \"GlueMsgGetEmbeddingsReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"gemb_res\": {\n        \"name\": \"gemb_res\",\n        \"structName\": \"glue_msg_get_embeddings_res\",\n        \"className\": \"GlueMsgGetEmbeddingsRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_float\",\n                \"name\": \"embeddings\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"kvcr_req\": {\n        \"name\": \"kvcr_req\",\n        \"structName\": \"glue_msg_get_kv_remove_req\",\n        \"className\": \"GlueMsgGetKvRemoveReq\",\n        \"fields\": [\n            {\n                \"type\": \"int\",\n                \"name\": \"n_keep\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_discard\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"kvcr_res\": {\n        \"name\": \"kvcr_res\",\n        \"structName\": \"glue_msg_get_kv_remove_res\",\n        \"className\": \"GlueMsgGetKvRemoveRes\",\n        \"fields\": [\n            {\n                \"type\": \"int\",\n                \"name\": \"n_past\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"kvcc_req\": {\n        \"name\": \"kvcc_req\",\n        \"structName\": \"glue_msg_get_kv_clear_req\",\n        \"className\": \"GlueMsgGetKvClearReq\",\n        \"fields\": []\n    },\n    \"kvcc_res\": {\n        \"name\": \"kvcc_res\",\n        \"structName\": \"glue_msg_get_kv_clear_res\",\n        \"className\": \"GlueMsgGetKvClearRes\",\n        \"fields\": [\n            {\n                \"type\": \"int\",\n                \"name\": \"n_past\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sesa_req\": {\n        \"name\": \"sesa_req\",\n        \"structName\": \"glue_msg_session_save_req\",\n        \"className\": \"GlueMsgSessionSaveReq\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"session_path\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sesa_res\": {\n        \"name\": \"sesa_res\",\n        \"structName\": \"glue_msg_session_save_res\",\n        \"className\": \"GlueMsgSessionSaveRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sesl_req\": {\n        \"name\": \"sesl_req\",\n        \"structName\": \"glue_msg_session_load_req\",\n        \"className\": \"GlueMsgSessionLoadReq\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"session_path\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"sesl_res\": {\n        \"name\": \"sesl_res\",\n        \"structName\": \"glue_msg_session_load_res\",\n        \"className\": \"GlueMsgSessionLoadRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"stat_req\": {\n        \"name\": \"stat_req\",\n        \"structName\": \"glue_msg_status_req\",\n        \"className\": \"GlueMsgStatusReq\",\n        \"fields\": []\n    },\n    \"stat_res\": {\n        \"name\": \"stat_res\",\n        \"structName\": \"glue_msg_status_res\",\n        \"className\": \"GlueMsgStatusRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"tben_req\": {\n        \"name\": \"tben_req\",\n        \"structName\": \"glue_msg_test_benchmark_req\",\n        \"className\": \"GlueMsgTestBenchmarkReq\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"type\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_samples\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"tben_res\": {\n        \"name\": \"tben_res\",\n        \"structName\": \"glue_msg_test_benchmark_res\",\n        \"className\": \"GlueMsgTestBenchmarkRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"t_ms\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"tper_req\": {\n        \"name\": \"tper_req\",\n        \"structName\": \"glue_msg_test_perplexity_req\",\n        \"className\": \"GlueMsgTestPerplexityReq\",\n        \"fields\": [\n            {\n                \"type\": \"arr_int\",\n                \"name\": \"tokens\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"tper_res\": {\n        \"name\": \"tper_res\",\n        \"structName\": \"glue_msg_test_perplexity_res\",\n        \"className\": \"GlueMsgTestPerplexityRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"ppl\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"nll\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"float\",\n                \"name\": \"cross_entropy\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"n_tokens\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"int\",\n                \"name\": \"t_ms\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"cfmt_req\": {\n        \"name\": \"cfmt_req\",\n        \"structName\": \"glue_msg_chat_format_req\",\n        \"className\": \"GlueMsgChatFormatReq\",\n        \"fields\": [\n            {\n                \"type\": \"str\",\n                \"name\": \"tmpl\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"add_ass\",\n                \"isNullable\": true\n            },\n            {\n                \"type\": \"arr_str\",\n                \"name\": \"roles\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"arr_str\",\n                \"name\": \"contents\",\n                \"isNullable\": false\n            }\n        ]\n    },\n    \"cfmt_res\": {\n        \"name\": \"cfmt_res\",\n        \"structName\": \"glue_msg_chat_format_res\",\n        \"className\": \"GlueMsgChatFormatRes\",\n        \"fields\": [\n            {\n                \"type\": \"bool\",\n                \"name\": \"success\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"message\",\n                \"isNullable\": false\n            },\n            {\n                \"type\": \"str\",\n                \"name\": \"formatted_chat\",\n                \"isNullable\": false\n            }\n        ]\n    }\n};\n//# sourceMappingURL=messages.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/glue/messages.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoggerWithoutDebug: () => (/* reexport safe */ _wllama_js__WEBPACK_IMPORTED_MODULE_0__.LoggerWithoutDebug),\n/* harmony export */   Model: () => (/* reexport safe */ _model_manager_js__WEBPACK_IMPORTED_MODULE_2__.Model),\n/* harmony export */   ModelManager: () => (/* reexport safe */ _model_manager_js__WEBPACK_IMPORTED_MODULE_2__.ModelManager),\n/* harmony export */   ModelValidationStatus: () => (/* reexport safe */ _model_manager_js__WEBPACK_IMPORTED_MODULE_2__.ModelValidationStatus),\n/* harmony export */   POLYFILL_ETAG: () => (/* reexport safe */ _cache_manager_js__WEBPACK_IMPORTED_MODULE_1__.POLYFILL_ETAG),\n/* harmony export */   Wllama: () => (/* reexport safe */ _wllama_js__WEBPACK_IMPORTED_MODULE_0__.Wllama),\n/* harmony export */   WllamaError: () => (/* reexport safe */ _wllama_js__WEBPACK_IMPORTED_MODULE_0__.WllamaError)\n/* harmony export */ });\n/* harmony import */ var _wllama_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wllama.js */ \"./node_modules/@wllama/wllama/esm/wllama.js\");\n/* harmony import */ var _cache_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache-manager.js */ \"./node_modules/@wllama/wllama/esm/cache-manager.js\");\n/* harmony import */ var _model_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model-manager.js */ \"./node_modules/@wllama/wllama/esm/model-manager.js\");\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/index.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/model-manager.js":
/*!**********************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/model-manager.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* binding */ Model),\n/* harmony export */   ModelManager: () => (/* binding */ ModelManager),\n/* harmony export */   ModelValidationStatus: () => (/* binding */ ModelValidationStatus)\n/* harmony export */ });\n/* harmony import */ var _cache_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache-manager.js */ \"./node_modules/@wllama/wllama/esm/cache-manager.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@wllama/wllama/esm/utils.js\");\n/* harmony import */ var _wllama_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wllama.js */ \"./node_modules/@wllama/wllama/esm/wllama.js\");\n\n\n\nconst DEFAULT_PARALLEL_DOWNLOADS = 3;\n/**\n * Status of the model validation\n */\nvar ModelValidationStatus;\n(function (ModelValidationStatus) {\n    ModelValidationStatus[\"VALID\"] = \"valid\";\n    ModelValidationStatus[\"INVALID\"] = \"invalid\";\n    ModelValidationStatus[\"DELETED\"] = \"deleted\";\n})(ModelValidationStatus || (ModelValidationStatus = {}));\n/**\n * Model class\n *\n * One model can have multiple shards, each shard is a GGUF file.\n */\nclass Model {\n    modelManager;\n    constructor(modelManager, url, savedFiles) {\n        this.modelManager = modelManager;\n        this.url = url;\n        if (savedFiles) {\n            // this file is already in cache\n            this.files = this.getAllFiles(savedFiles);\n            this.size = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sumArr)(this.files.map((f) => f.metadata.originalSize));\n        }\n        else {\n            // this file is not in cache, we are about to download it\n            this.files = [];\n            this.size = 0;\n        }\n    }\n    /**\n     * URL to the GGUF file (in case it contains multiple shards, the URL should point to the first shard)\n     *\n     * This URL will be used to identify the model in the cache. There can't be 2 models with the same URL.\n     */\n    url;\n    /**\n     * Size in bytes (total size of all shards).\n     *\n     * A value of -1 means the model is deleted from the cache. You must call `ModelManager.downloadModel` to re-download the model.\n     */\n    size;\n    /**\n     * List of all shards in the cache, sorted by original URL (ascending order)\n     */\n    files;\n    /**\n     * Open and get a list of all shards as Blobs\n     */\n    async open() {\n        if (this.size === -1) {\n            throw new _wllama_js__WEBPACK_IMPORTED_MODULE_2__.WllamaError(`Model is deleted from the cache; Call ModelManager.downloadModel to re-download the model`, 'load_error');\n        }\n        const blobs = [];\n        for (const file of this.files) {\n            const blob = await this.modelManager.cacheManager.open(file.name);\n            if (!blob) {\n                throw new Error(`Failed to open file ${file.name}; Hint: the model may be invalid, please refresh it`);\n            }\n            blobs.push(blob);\n        }\n        return blobs;\n    }\n    /**\n     * Validate the model files.\n     *\n     * If the model is invalid, the model manager will not be able to use it. You must call `refresh` to re-download the model.\n     *\n     * Cases that model is invalid:\n     * - The model is deleted from the cache\n     * - The model files are missing (or the download is interrupted)\n     */\n    validate() {\n        const nbShards = ModelManager.parseModelUrl(this.url).length;\n        if (this.size === -1) {\n            return ModelValidationStatus.DELETED;\n        }\n        if (this.size < 16 || this.files.length !== nbShards) {\n            return ModelValidationStatus.INVALID;\n        }\n        for (const file of this.files) {\n            if (!file.metadata || file.metadata.originalSize !== file.size) {\n                return ModelValidationStatus.INVALID;\n            }\n        }\n        return ModelValidationStatus.VALID;\n    }\n    /**\n     * In case the model is invalid, call this function to re-download the model\n     */\n    async refresh(options = {}) {\n        const urls = ModelManager.parseModelUrl(this.url);\n        const works = urls.map((url, index) => ({\n            url,\n            index,\n        }));\n        this.modelManager.logger.debug('Downloading model files:', urls);\n        const nParallel = this.modelManager.params.parallelDownloads ?? DEFAULT_PARALLEL_DOWNLOADS;\n        const totalSize = await this.getTotalDownloadSize(urls);\n        const loadedSize = [];\n        const worker = async () => {\n            while (works.length > 0) {\n                const w = works.shift();\n                if (!w)\n                    break;\n                await this.modelManager.cacheManager.download(w.url, {\n                    ...options,\n                    progressCallback: ({ loaded }) => {\n                        loadedSize[w.index] = loaded;\n                        options.progressCallback?.({\n                            loaded: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sumArr)(loadedSize),\n                            total: totalSize,\n                        });\n                    },\n                });\n            }\n        };\n        const promises = [];\n        for (let i = 0; i < nParallel; i++) {\n            promises.push(worker());\n            loadedSize.push(0);\n        }\n        await Promise.all(promises);\n        this.files = this.getAllFiles(await this.modelManager.cacheManager.list());\n        this.size = this.files.reduce((acc, f) => acc + f.metadata.originalSize, 0);\n    }\n    /**\n     * Remove the model from the cache\n     */\n    async remove() {\n        this.files = this.getAllFiles(await this.modelManager.cacheManager.list());\n        await this.modelManager.cacheManager.deleteMany((f) => !!this.files.find((file) => file.name === f.name));\n        this.size = -1;\n    }\n    getAllFiles(savedFiles) {\n        const allUrls = new Set(ModelManager.parseModelUrl(this.url));\n        const allFiles = [];\n        for (const url of allUrls) {\n            const file = savedFiles.find((f) => f.metadata.originalURL === url);\n            if (!file) {\n                throw new Error(`Model file not found: ${url}`);\n            }\n            allFiles.push(file);\n        }\n        allFiles.sort((a, b) => a.metadata.originalURL.localeCompare(b.metadata.originalURL));\n        return allFiles;\n    }\n    async getTotalDownloadSize(urls) {\n        const responses = await Promise.all(urls.map((url) => fetch(url, { method: 'HEAD' })));\n        const sizes = responses.map((res) => Number(res.headers.get('content-length') || '0'));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sumArr)(sizes);\n    }\n}\nclass ModelManager {\n    // The CacheManager singleton, can be accessed by user\n    cacheManager;\n    params;\n    logger;\n    constructor(params = {}) {\n        this.cacheManager = params.cacheManager || new _cache_manager_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.params = params;\n        this.logger = params.logger || console;\n    }\n    /**\n     * Parses a model URL and returns an array of URLs based on the following patterns:\n     * - If the input URL is an array, it returns the array itself.\n     * - If the input URL is a string in the `gguf-split` format, it returns an array containing the URL of each shard in ascending order.\n     * - Otherwise, it returns an array containing the input URL as a single element array.\n     * @param modelUrl URL or list of URLs\n     */\n    static parseModelUrl(modelUrl) {\n        if (Array.isArray(modelUrl)) {\n            return modelUrl;\n        }\n        const urlPartsRegex = /-(\\d{5})-of-(\\d{5})\\.gguf$/;\n        const matches = modelUrl.match(urlPartsRegex);\n        if (!matches) {\n            return [modelUrl];\n        }\n        const baseURL = modelUrl.replace(urlPartsRegex, '');\n        const total = matches[2];\n        const paddedShardIds = Array.from({ length: Number(total) }, (_, index) => (index + 1).toString().padStart(5, '0'));\n        return paddedShardIds.map((current) => `${baseURL}-${current}-of-${total}.gguf`);\n    }\n    /**\n     * Get all models in the cache\n     */\n    async getModels(opts = {}) {\n        const cachedFiles = await this.cacheManager.list();\n        let models = [];\n        for (const file of cachedFiles) {\n            const shards = ModelManager.parseModelUrl(file.metadata.originalURL);\n            const isFirstShard = shards.length === 1 || shards[0] === file.metadata.originalURL;\n            if (isFirstShard) {\n                models.push(new Model(this, file.metadata.originalURL, cachedFiles));\n            }\n        }\n        if (!opts.includeInvalid) {\n            models = models.filter((m) => m.validate() === ModelValidationStatus.VALID);\n        }\n        return models;\n    }\n    /**\n     * Download a model from the given URL.\n     *\n     * The URL must end with `.gguf`\n     */\n    async downloadModel(url, options = {}) {\n        if (!url.endsWith('.gguf')) {\n            throw new _wllama_js__WEBPACK_IMPORTED_MODULE_2__.WllamaError(`Invalid model URL: ${url}; URL must ends with \".gguf\"`, 'download_error');\n        }\n        const model = new Model(this, url, undefined);\n        const validity = model.validate();\n        if (validity !== ModelValidationStatus.VALID) {\n            await model.refresh(options);\n        }\n        return model;\n    }\n    /**\n     * Get a model from the cache or download it if it's not available.\n     */\n    async getModelOrDownload(url, options = {}) {\n        const models = await this.getModels();\n        const model = models.find((m) => m.url === url);\n        if (model) {\n            options.progressCallback?.({ loaded: model.size, total: model.size });\n            return model;\n        }\n        return this.downloadModel(url, options);\n    }\n    /**\n     * Remove all models from the cache\n     */\n    async clear() {\n        await this.cacheManager.clear();\n    }\n}\n//# sourceMappingURL=model-manager.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/model-manager.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absoluteUrl: () => (/* binding */ absoluteUrl),\n/* harmony export */   bufToText: () => (/* binding */ bufToText),\n/* harmony export */   checkEnvironmentCompatible: () => (/* binding */ checkEnvironmentCompatible),\n/* harmony export */   createWorker: () => (/* binding */ createWorker),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   getWModuleConfig: () => (/* binding */ getWModuleConfig),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isSafariMobile: () => (/* binding */ isSafariMobile),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isSupportMultiThread: () => (/* binding */ isSupportMultiThread),\n/* harmony export */   joinBuffers: () => (/* binding */ joinBuffers),\n/* harmony export */   padDigits: () => (/* binding */ padDigits),\n/* harmony export */   parseModelUrl: () => (/* binding */ parseModelUrl),\n/* harmony export */   parseShardNumber: () => (/* binding */ parseShardNumber),\n/* harmony export */   sortFileByShard: () => (/* binding */ sortFileByShard),\n/* harmony export */   sumArr: () => (/* binding */ sumArr)\n/* harmony export */ });\nconst joinBuffers = (buffers) => {\n    const totalSize = buffers.reduce((acc, buf) => acc + buf.length, 0);\n    const output = new Uint8Array(totalSize);\n    output.set(buffers[0], 0);\n    for (let i = 1; i < buffers.length; i++) {\n        output.set(buffers[i], buffers[i - 1].length);\n    }\n    return output;\n};\nconst textDecoder = new TextDecoder();\n/**\n * Convert list of bytes (number) to text\n * @param buffer\n * @returns a string\n */\nconst bufToText = (buffer) => {\n    return textDecoder.decode(buffer);\n};\n/**\n * Get default stdout/stderr config for wasm module\n */\nconst getWModuleConfig = (pathConfig) => {\n    return {\n        noInitialRun: true,\n        print: function (text) {\n            if (arguments.length > 1)\n                text = Array.prototype.slice.call(arguments).join(' ');\n            console.log(text);\n        },\n        printErr: function (text) {\n            if (arguments.length > 1)\n                text = Array.prototype.slice.call(arguments).join(' ');\n            console.warn(text);\n        },\n        // @ts-ignore\n        locateFile: function (filename, basePath) {\n            const p = pathConfig[filename];\n            console.log(`Loading \"${filename}\" from \"${p}\"`);\n            return p;\n        },\n    };\n};\nconst URL_PARTS_REGEX = /-(\\d{5})-of-(\\d{5})\\.gguf$/;\n/**\n * Parse shard number and total from a file name or URL\n */\nconst parseShardNumber = (fnameOrUrl) => {\n    const matches = fnameOrUrl.match(URL_PARTS_REGEX);\n    if (!matches) {\n        return {\n            baseURL: fnameOrUrl,\n            current: 1,\n            total: 1,\n        };\n    }\n    else {\n        return {\n            baseURL: fnameOrUrl.replace(URL_PARTS_REGEX, ''),\n            current: parseInt(matches[1]),\n            total: parseInt(matches[2]),\n        };\n    }\n};\n/**\n * Parses a model URL and returns an array of URLs based on the following patterns:\n * - If the input URL is an array, it returns the array itself.\n * - If the input URL is a string in the `gguf-split` format, it returns an array containing the URL of each shard in ascending order.\n * - Otherwise, it returns an array containing the input URL as a single element array.\n * @param modelUrl URL or list of URLs\n */\nconst parseModelUrl = (modelUrl) => {\n    const { baseURL, current, total } = parseShardNumber(modelUrl);\n    if (current == total && total == 1) {\n        return [modelUrl];\n    }\n    else {\n        const paddedShardIds = Array.from({ length: total }, (_, index) => (index + 1).toString().padStart(5, '0'));\n        return paddedShardIds.map((current) => `${baseURL}-${current}-of-${total.toString().padStart(5, '0')}.gguf`);\n    }\n};\n/**\n * Check if the given blobs are files or not, then sort them by shard number\n */\nconst sortFileByShard = (blobs) => {\n    const isFiles = blobs.every((b) => !!b.name);\n    if (isFiles && blobs.length > 1) {\n        const files = blobs;\n        files.sort((a, b) => {\n            const infoA = parseShardNumber(a.name);\n            const infoB = parseShardNumber(b.name);\n            return infoA.current - infoB.current;\n        });\n    }\n};\nconst delay = (ms) => new Promise((r) => setTimeout(r, ms));\nconst absoluteUrl = (relativePath) => new URL(relativePath, document.baseURI).href;\nconst padDigits = (number, digits) => {\n    return (Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number);\n};\nconst sumArr = (arr) => arr.reduce((prev, curr) => prev + curr, 0);\nconst isString = (value) => !!value?.startsWith;\n/**\n * Browser feature detection\n * Copied from https://unpkg.com/wasm-feature-detect?module (Apache License)\n */\n/**\n * @returns true if browser support multi-threads\n */\nconst isSupportMultiThread = () => (async (e) => {\n    try {\n        return ('undefined' != typeof MessageChannel &&\n            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),\n            WebAssembly.validate(e));\n    }\n    catch (e) {\n        return !1;\n    }\n})(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1,\n    1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11,\n]));\n/**\n * @returns true if browser support wasm \"native\" exception handler\n */\nconst isSupportExceptions = async () => WebAssembly.validate(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,\n    0, 6, 64, 25, 11, 11,\n]));\n/**\n * @returns true if browser support wasm SIMD\n */\nconst isSupportSIMD = async () => WebAssembly.validate(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10,\n    1, 8, 0, 65, 0, 253, 15, 253, 98, 11,\n]));\n/**\n * Throws an error if the environment is not compatible\n */\nconst checkEnvironmentCompatible = async () => {\n    if (!(await isSupportExceptions())) {\n        throw new Error('WebAssembly runtime does not support exception handling');\n    }\n    if (!(await isSupportSIMD())) {\n        throw new Error('WebAssembly runtime does not support SIMD');\n    }\n};\n/**\n * Check if browser is Safari\n * Source: https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\n */\nconst isSafari = () => {\n    return (isSafariMobile() ||\n        !!navigator.userAgent.match(/Version\\/([0-9\\._]+).*Safari/)); // safari\n};\n/**\n * Check if browser is Safari iOS / iPad / iPhone\n * Source: https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\n */\nconst isSafariMobile = () => {\n    return !!navigator.userAgent.match(/Version\\/([0-9\\._]+).*Mobile.*Safari.*/); // ios\n};\n/**\n * Create a worker from a string\n */\nconst createWorker = (workerCode) => {\n    const workerURL = URL.createObjectURL(isString(workerCode)\n        ? new Blob([workerCode], { type: 'text/javascript' })\n        : workerCode);\n    return new Worker(workerURL, { type: 'module' });\n};\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/utils.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/wllama.js":
/*!***************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/wllama.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoggerWithoutDebug: () => (/* binding */ LoggerWithoutDebug),\n/* harmony export */   Wllama: () => (/* binding */ Wllama),\n/* harmony export */   WllamaError: () => (/* binding */ WllamaError)\n/* harmony export */ });\n/* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker.js */ \"./node_modules/@wllama/wllama/esm/worker.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@wllama/wllama/esm/utils.js\");\n/* harmony import */ var _cache_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache-manager.js */ \"./node_modules/@wllama/wllama/esm/cache-manager.js\");\n/* harmony import */ var _model_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model-manager.js */ \"./node_modules/@wllama/wllama/esm/model-manager.js\");\n\n\n\n\nconst HF_MODEL_ID_REGEX = /^([a-zA-Z0-9_\\-\\.]+)\\/([a-zA-Z0-9_\\-\\.]+)$/;\nconst HF_MODEL_ID_REGEX_EXPLAIN = \"Hugging Face model ID is incorrect. Only regular alphanumeric characters, '-', '.' and '_' supported\";\n/**\n * Logger preset with debug messages suppressed\n */\nconst LoggerWithoutDebug = {\n    ...console,\n    debug: () => { },\n};\nclass WllamaError extends Error {\n    type;\n    constructor(message, type = 'unknown_error') {\n        super(message);\n        this.type = type;\n    }\n}\nclass Wllama {\n    // The CacheManager and ModelManager are singleton, can be accessed by user\n    cacheManager;\n    modelManager;\n    proxy = null;\n    config;\n    pathConfig;\n    useMultiThread = false;\n    nbThreads = 1;\n    useEmbeddings = false;\n    // available when loaded\n    loadedContextInfo = null;\n    bosToken = -1;\n    eosToken = -1;\n    eotToken = -1;\n    eogTokens = new Set();\n    addBosToken = false;\n    addEosToken = false;\n    chatTemplate;\n    metadata;\n    samplingConfig = {};\n    hasEncoder = false;\n    decoderStartToken = -1;\n    nCachedTokens = 0;\n    constructor(pathConfig, wllamaConfig = {}) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkEnvironmentCompatible)();\n        if (!pathConfig)\n            throw new WllamaError('AssetsPathConfig is required');\n        this.pathConfig = pathConfig;\n        this.config = wllamaConfig;\n        this.cacheManager = wllamaConfig.cacheManager ?? new _cache_manager_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.modelManager =\n            wllamaConfig.modelManager ??\n                new _model_manager_js__WEBPACK_IMPORTED_MODULE_3__.ModelManager({\n                    cacheManager: this.cacheManager,\n                    logger: wllamaConfig.logger ?? console,\n                    parallelDownloads: wllamaConfig.parallelDownloads,\n                    allowOffline: wllamaConfig.allowOffline,\n                });\n    }\n    logger() {\n        return this.config.logger ?? console;\n    }\n    checkModelLoaded() {\n        if (!this.isModelLoaded()) {\n            throw new WllamaError('loadModel() is not yet called', 'model_not_loaded');\n        }\n    }\n    /**\n     * Check if the model is loaded via `loadModel()`\n     */\n    isModelLoaded() {\n        return !!this.proxy && !!this.metadata;\n    }\n    /**\n     * Get token ID associated to BOS (begin of sentence) token.\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns -1 if the model is not loaded.\n     */\n    getBOS() {\n        return this.bosToken;\n    }\n    /**\n     * Get token ID associated to EOS (end of sentence) token.\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns -1 if the model is not loaded.\n     */\n    getEOS() {\n        return this.eosToken;\n    }\n    /**\n     * Get token ID associated to EOT (end of turn) token.\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns -1 if the model is not loaded.\n     */\n    getEOT() {\n        return this.eotToken;\n    }\n    /**\n     * Check if a given token is end-of-generation token (e.g. EOS, EOT, etc.)\n     *\n     * @param token the token ID to be checked\n     * @returns true if the token is EOS, EOT, or any other end-of-generation tokens\n     */\n    isTokenEOG(token) {\n        return (token === this.eosToken ||\n            token === this.eotToken ||\n            this.eogTokens.has(token));\n    }\n    /**\n     * Get token ID associated to token used by decoder, to start generating output sequence(only usable for encoder-decoder architecture). In other words, encoder uses normal BOS and decoder uses this token.\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns -1 if the model is not loaded.\n     */\n    getDecoderStartToken() {\n        return this.decoderStartToken;\n    }\n    /**\n     * Get model hyper-parameters and metadata\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns ModelMetadata\n     */\n    getModelMetadata() {\n        this.checkModelLoaded();\n        return this.metadata;\n    }\n    /**\n     * Check if we're currently using multi-thread build.\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns true if multi-thread is used.\n     */\n    isMultithread() {\n        this.checkModelLoaded();\n        return this.useMultiThread;\n    }\n    /**\n     * Get number of threads used in the current context.\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns number of threads\n     */\n    getNumThreads() {\n        this.checkModelLoaded();\n        return this.useMultiThread ? this.nbThreads : 1;\n    }\n    /**\n     * Check if the current model uses encoder-decoder architecture\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns true if multi-thread is used.\n     */\n    isEncoderDecoderArchitecture() {\n        this.checkModelLoaded();\n        return this.hasEncoder;\n    }\n    /**\n     * Must we add BOS token to the tokenized sequence?\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns true if BOS token must be added to the sequence\n     */\n    mustAddBosToken() {\n        this.checkModelLoaded();\n        return this.addBosToken;\n    }\n    /**\n     * Must we add EOS token to the tokenized sequence?\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns true if EOS token must be added to the sequence\n     */\n    mustAddEosToken() {\n        this.checkModelLoaded();\n        return this.addEosToken;\n    }\n    /**\n     * Get the jinja chat template comes with the model. It only available if the original model (before converting to gguf) has the template in `tokenizer_config.json`\n     *\n     * NOTE: This can only being used after `loadModel` is called.\n     *\n     * @returns the jinja template. null if there is no template in gguf\n     */\n    getChatTemplate() {\n        this.checkModelLoaded();\n        return this.chatTemplate ?? null;\n    }\n    /**\n     * Load model from a given URL (or a list of URLs, in case the model is splitted into smaller files)\n     * - If the model already been downloaded (via `downloadModel()`), then we will use the cached model\n     * - Else, we download the model from internet\n     * @param modelUrl URL to the GGUF file. If the model is splitted, pass the URL to the first shard.\n     * @param config\n     */\n    async loadModelFromUrl(modelUrl, config = {}) {\n        const url = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(modelUrl) ? modelUrl : modelUrl[0];\n        const useCache = config.useCache ?? true;\n        const model = useCache\n            ? await this.modelManager.getModelOrDownload(url, config)\n            : await this.modelManager.downloadModel(url, config);\n        const blobs = await model.open();\n        return await this.loadModel(blobs, config);\n    }\n    /**\n     * Load model from a given Hugging Face model ID and file path.\n     *\n     * @param modelId The HF model ID, for example: 'ggml-org/models'\n     * @param filePath The GGUF file path, for example: 'tinyllamas/stories15M-q4_0.gguf'\n     * @param config\n     */\n    async loadModelFromHF(modelId, filePath, config = {}) {\n        if (!modelId.match(HF_MODEL_ID_REGEX)) {\n            throw new WllamaError(HF_MODEL_ID_REGEX_EXPLAIN, 'download_error');\n        }\n        if (!filePath.endsWith('.gguf')) {\n            throw new WllamaError('Only GGUF file is supported', 'download_error');\n        }\n        return await this.loadModelFromUrl(`https://huggingface.co/${modelId}/resolve/main/${filePath}`, config);\n    }\n    /**\n     * Load model from a given list of Blob.\n     *\n     * You can pass multiple buffers into the function (in case the model contains multiple shards).\n     *\n     * @param ggufBlobsOrModel Can be either list of Blobs (in case you use local file), or a Model object (in case you use ModelManager)\n     * @param config LoadModelConfig\n     */\n    async loadModel(ggufBlobsOrModel, config = {}) {\n        const blobs = ggufBlobsOrModel instanceof _model_manager_js__WEBPACK_IMPORTED_MODULE_3__.Model\n            ? await ggufBlobsOrModel.open()\n            : [...ggufBlobsOrModel]; // copy array\n        if (blobs.some((b) => b.size === 0)) {\n            throw new WllamaError('Input model (or splits) must be non-empty Blob or File', 'load_error');\n        }\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sortFileByShard)(blobs);\n        if (this.proxy) {\n            throw new WllamaError('Module is already initialized', 'load_error');\n        }\n        // detect if we can use multi-thread\n        const supportMultiThread = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isSupportMultiThread)();\n        if (!supportMultiThread) {\n            this.logger().warn('Multi-threads are not supported in this environment, falling back to single-thread');\n        }\n        const hasPathMultiThread = !!this.pathConfig['multi-thread/wllama.wasm'];\n        if (!hasPathMultiThread) {\n            this.logger().warn('Missing paths to \"multi-thread/wllama.wasm\", falling back to single-thread');\n        }\n        const hwConccurency = Math.floor((navigator.hardwareConcurrency || 1) / 2);\n        const nbThreads = config.n_threads ?? hwConccurency;\n        this.nbThreads = nbThreads;\n        this.useMultiThread =\n            supportMultiThread && hasPathMultiThread && nbThreads > 1;\n        const mPathConfig = this.useMultiThread\n            ? {\n                'wllama.wasm': (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.absoluteUrl)(this.pathConfig['multi-thread/wllama.wasm']),\n            }\n            : {\n                'wllama.wasm': (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.absoluteUrl)(this.pathConfig['single-thread/wllama.wasm']),\n            };\n        this.proxy = new _worker_js__WEBPACK_IMPORTED_MODULE_0__.ProxyToWorker(mPathConfig, this.useMultiThread ? nbThreads : 1, this.config.suppressNativeLog ?? false, this.logger());\n        const modelFiles = blobs.map((blob, i) => ({\n            name: `model-${i}.gguf`,\n            blob,\n        }));\n        await this.proxy.moduleInit(modelFiles);\n        // run it\n        const startResult = await this.proxy.wllamaStart();\n        if (!startResult.success) {\n            throw new WllamaError(`Error while calling start function, result = ${startResult}`);\n        }\n        // load the model\n        const loadResult = await this.proxy.wllamaAction('load', {\n            _name: 'load_req',\n            use_mmap: true,\n            use_mlock: true,\n            n_gpu_layers: 0, // not supported for now\n            seed: config.seed || Math.floor(Math.random() * 100000),\n            n_ctx: config.n_ctx || 1024,\n            n_threads: this.useMultiThread ? nbThreads : 1,\n            n_ctx_auto: false, // not supported for now\n            model_paths: modelFiles.map((f) => `models/${f.name}`),\n            embeddings: config.embeddings,\n            offload_kqv: config.offload_kqv,\n            n_batch: config.n_batch,\n            pooling_type: config.pooling_type,\n            rope_scaling_type: config.rope_scaling_type,\n            rope_freq_base: config.rope_freq_base,\n            rope_freq_scale: config.rope_freq_scale,\n            yarn_ext_factor: config.yarn_ext_factor,\n            yarn_attn_factor: config.yarn_attn_factor,\n            yarn_beta_fast: config.yarn_beta_fast,\n            yarn_beta_slow: config.yarn_beta_slow,\n            yarn_orig_ctx: config.yarn_orig_ctx,\n            cache_type_k: config.cache_type_k,\n            cache_type_v: config.cache_type_v,\n        });\n        const loadedCtxInfo = {\n            ...loadResult,\n            metadata: {},\n        };\n        for (let i = 0; i < loadResult.metadata_key.length; i++) {\n            loadedCtxInfo.metadata[loadResult.metadata_key[i]] =\n                loadResult.metadata_val[i];\n        }\n        this.bosToken = loadedCtxInfo.token_bos;\n        this.eosToken = loadedCtxInfo.token_eos;\n        this.eotToken = loadedCtxInfo.token_eot;\n        this.useEmbeddings = !!config.embeddings;\n        this.metadata = {\n            hparams: {\n                nVocab: loadedCtxInfo.n_vocab,\n                nCtxTrain: loadedCtxInfo.n_ctx_train,\n                nEmbd: loadedCtxInfo.n_embd,\n                nLayer: loadedCtxInfo.n_layer,\n            },\n            meta: loadedCtxInfo.metadata,\n        };\n        this.hasEncoder = !!loadedCtxInfo.has_encoder;\n        this.decoderStartToken = loadedCtxInfo.token_decoder_start;\n        this.addBosToken = loadedCtxInfo.add_bos_token;\n        this.addEosToken = loadedCtxInfo.add_eos_token;\n        this.chatTemplate = loadedCtxInfo.metadata['tokenizer.chat_template'];\n        this.loadedContextInfo = loadedCtxInfo;\n        this.eogTokens = new Set(loadedCtxInfo.list_tokens_eog);\n        this.logger().debug({ loadedCtxInfo });\n    }\n    getLoadedContextInfo() {\n        this.checkModelLoaded();\n        if (!this.loadedContextInfo) {\n            throw new WllamaError('Loaded context info is not available');\n        }\n        // copy object\n        return { ...this.loadedContextInfo };\n    }\n    //////////////////////////////////////////////\n    // High level API\n    /**\n     * Calculate embedding vector for a given text.\n     * By default, BOS and EOS tokens will be added automatically. You can use the \"skipBOS\" and \"skipEOS\" option to disable it.\n     * @param text Input text\n     * @returns An embedding vector\n     */\n    async createEmbedding(text, options = {}) {\n        this.checkModelLoaded();\n        const opt = {\n            skipBOS: false,\n            skipEOS: false,\n            ...options,\n        };\n        await this.samplingInit(this.samplingConfig);\n        await this.kvClear();\n        const tokens = await this.tokenize(text);\n        if (this.bosToken && !opt.skipBOS) {\n            tokens.unshift(this.bosToken);\n        }\n        if (this.eosToken && !opt.skipEOS) {\n            tokens.push(this.eosToken);\n        }\n        const result = await this.embeddings(tokens);\n        return result;\n    }\n    /**\n     * Make completion for a given chat messages.\n     *\n     * NOTE: this function uses the chat template (if available) to format the chat messages. If the template is not available, it will use the default format (chatml). It can throw an error if the chat template is not compatible.\n     *\n     * @param messages Chat messages\n     * @param options\n     * @returns Output completion text (only the completion part)\n     */\n    async createChatCompletion(messages, options) {\n        const prompt = await this.formatChat(messages, true);\n        return await this.createCompletion(prompt, options);\n    }\n    /**\n     * Make completion for a given text.\n     * @param prompt Input text\n     * @param options\n     * @returns Output completion text (only the completion part)\n     */\n    async createCompletion(prompt, options) {\n        this.checkModelLoaded();\n        this.samplingConfig = options.sampling ?? {};\n        await this.samplingInit(this.samplingConfig);\n        const stopTokens = new Set(options.stopTokens ?? []);\n        // process prompt\n        let tokens = await this.tokenize(prompt, true);\n        if (this.addBosToken && tokens[0] !== this.bosToken) {\n            tokens.unshift(this.bosToken);\n        }\n        // maybe reuse KV cache\n        if (options.useCache) {\n            tokens = await this.computeNonCachedTokens(tokens);\n        }\n        else {\n            await this.kvClear();\n        }\n        // decode/encode tokens\n        await this.samplingAccept(tokens);\n        if (this.isEncoderDecoderArchitecture()) {\n            await this.encode(tokens);\n            await this.decode([this.getDecoderStartToken()], {});\n        }\n        else {\n            await this.decode(tokens, {});\n        }\n        let outBuf = new Uint8Array();\n        // abort signal\n        let abort = false;\n        const abortSignal = () => {\n            abort = true;\n        };\n        // predict next tokens\n        for (let i = 0; i < (options.nPredict ?? Infinity); i++) {\n            const sampled = await this.samplingSample();\n            if (this.isTokenEOG(sampled.token) || stopTokens.has(sampled.token)) {\n                break; // stop token\n            }\n            // @ts-ignore Type 'Uint8Array<ArrayBufferLike>' is not assignable to type 'Uint8Array<ArrayBuffer>'\n            outBuf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.joinBuffers)([outBuf, sampled.piece]);\n            if (options.onNewToken) {\n                options.onNewToken(sampled.token, sampled.piece, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bufToText)(outBuf), {\n                    abortSignal,\n                });\n            }\n            if (abort) {\n                break; // abort signal is set\n            }\n            // decode next token\n            await this.samplingAccept([sampled.token]);\n            await this.decode([sampled.token], {});\n        }\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bufToText)(outBuf);\n    }\n    //////////////////////////////////////////////\n    // Low level API\n    /**\n     * Create or reset the ctx_sampling\n     * @param config\n     * @param pastTokens In case re-initializing the ctx_sampling, you can re-import past tokens into the new context\n     */\n    async samplingInit(config, pastTokens = []) {\n        this.checkModelLoaded();\n        this.samplingConfig = config;\n        const result = await this.proxy.wllamaAction('sampling_init', {\n            _name: 'sint_req',\n            ...config,\n            tokens: pastTokens,\n        });\n        if (!result.success) {\n            throw new WllamaError('Failed to initialize sampling');\n        }\n    }\n    /**\n     * Get a list of pieces in vocab.\n     * NOTE: This function is slow, should only be used once.\n     * @returns A list of Uint8Array. The nth element in the list associated to nth token in vocab\n     */\n    async getVocab() {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('get_vocab', {\n            _name: 'gvoc_req',\n        });\n        return result.vocab;\n    }\n    /**\n     * Lookup to see if a token exist in vocab or not. Useful for searching special tokens like \"<|im_start|>\"\n     * NOTE: It will match the whole token, so do not use it as a replacement for tokenize()\n     * @param piece\n     * @returns Token ID associated to the given piece. Returns -1 if cannot find the token.\n     */\n    async lookupToken(piece) {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('lookup_token', {\n            _name: 'lkup_req',\n            piece,\n        });\n        if (!result.success) {\n            return -1;\n        }\n        else {\n            return result.token;\n        }\n    }\n    /**\n     * Convert a given text to list of tokens\n     * @param text\n     * @param special Should split special tokens?\n     * @returns List of token ID\n     */\n    async tokenize(text, special = true) {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('tokenize', {\n            _name: 'tokn_req',\n            text,\n            special: !!special,\n        });\n        return result.tokens;\n    }\n    /**\n     * Convert a list of tokens to text\n     * @param tokens\n     * @returns Uint8Array, which maybe an unfinished unicode\n     */\n    async detokenize(tokens) {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('detokenize', {\n            _name: 'dtkn_req',\n            tokens,\n        });\n        return result.buffer;\n    }\n    /**\n     * Run llama_decode()\n     * @param tokens A list of tokens to be decoded\n     * @param options\n     * @returns n_past (number of tokens so far in the sequence)\n     */\n    async decode(tokens, options) {\n        this.checkModelLoaded();\n        if (this.useEmbeddings) {\n            throw new WllamaError('embeddings is enabled. Use wllama.setOptions({ embeddings: false }) to disable it.');\n        }\n        if (tokens.length === 0) {\n            // do not call llama_decode if list of tokens is empty\n            return {\n                nPast: this.nCachedTokens,\n            };\n        }\n        if (this.nCachedTokens + tokens.length > this.loadedContextInfo.n_ctx) {\n            throw new WllamaError('Running out of context cache. Please increase n_ctx when loading the model', 'kv_cache_full');\n        }\n        const batches = this.breakTokensIntoBatches(tokens, this.loadedContextInfo.n_batch);\n        let result;\n        for (let i = 0; i < batches.length; i++) {\n            const isNotLast = batches.length > 1 && i < batches.length - 1;\n            result = await this.proxy.wllamaAction('decode', {\n                _name: 'deco_req',\n                tokens: batches[i],\n                skip_logits: options.skipLogits || isNotLast,\n            });\n            if (result.error) {\n                throw new WllamaError(result.error);\n            }\n            else if (!result.success) {\n                throw new WllamaError('Cannot encode, unknown error');\n            }\n        }\n        this.nCachedTokens = result.n_past;\n        return { nPast: result.n_past };\n    }\n    /**\n     * Run llama_encode()\n     * @param tokens A list of tokens to be encoded\n     * @param options Unused for now\n     * @returns n_past (number of tokens so far in the sequence)\n     */\n    async encode(tokens, \n    // @ts-ignore unused variable\n    options) {\n        this.checkModelLoaded();\n        if (!this.hasEncoder) {\n            throw new WllamaError('This model does not use encoder-decoder architecture.', 'inference_error');\n        }\n        if (this.useEmbeddings) {\n            throw new WllamaError('embeddings is enabled. Use wllama.setOptions({ embeddings: false }) to disable it.', 'inference_error');\n        }\n        if (tokens.length === 0) {\n            // do not call llama_encode if list of tokens is empty\n            return {\n                nPast: this.nCachedTokens,\n            };\n        }\n        if (this.nCachedTokens + tokens.length > this.loadedContextInfo.n_ctx) {\n            throw new WllamaError('Running out of context cache. Please increase n_ctx when loading the model', 'kv_cache_full');\n        }\n        const batches = this.breakTokensIntoBatches(tokens, this.loadedContextInfo.n_batch);\n        let result;\n        for (let i = 0; i < batches.length; i++) {\n            result = await this.proxy.wllamaAction('encode', {\n                _name: 'enco_req',\n                tokens: batches[i],\n            });\n            if (result.error) {\n                throw new WllamaError(result.error);\n            }\n            else if (!result.success) {\n                throw new WllamaError('Cannot encode, unknown error');\n            }\n        }\n        this.nCachedTokens = result.n_past;\n        return { nPast: result.n_past };\n    }\n    breakTokensIntoBatches(tokens, maxBatchSize) {\n        const batches = [];\n        for (let i = 0; i < tokens.length; i += maxBatchSize) {\n            batches.push(tokens.slice(i, i + maxBatchSize));\n        }\n        return batches;\n    }\n    /**\n     * Sample a new token (remember to samplingInit() at least once before calling this function)\n     * @returns the token ID and its detokenized value (which maybe an unfinished unicode)\n     */\n    async samplingSample() {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('sampling_sample', {\n            _name: 'ssam_req',\n        });\n        return {\n            piece: result.piece,\n            token: result.token,\n        };\n    }\n    /**\n     * Accept and save a new token to ctx_sampling\n     * @param tokens\n     */\n    async samplingAccept(tokens) {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('sampling_accept', {\n            _name: 'sacc_req',\n            tokens,\n        });\n        if (!result.success) {\n            throw new WllamaError('samplingAccept unknown error');\n        }\n    }\n    /**\n     * Get softmax-ed probability of logits, can be used for custom sampling\n     * @param topK Get top K tokens having highest logits value. If topK == -1, we return all n_vocab logits, but this is not recommended because it's slow.\n     */\n    async getLogits(topK = 40) {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('get_logits', {\n            _name: 'glog_req',\n            top_k: topK,\n        });\n        const logits = [];\n        for (let i = 0; i < result.tokens.length; i++) {\n            logits.push({\n                token: result.tokens[i],\n                p: result.probs[i],\n            });\n        }\n        return logits;\n    }\n    /**\n     * Calculate embeddings for a given list of tokens. Output vector is always normalized\n     * @param tokens\n     * @returns A list of number represents an embedding vector of N dimensions\n     */\n    async embeddings(tokens) {\n        this.checkModelLoaded();\n        if (!this.useEmbeddings) {\n            throw new WllamaError('embeddings is disabled. Use wllama.setOptions({ embeddings: true }) to enable it.', 'inference_error');\n        }\n        if (this.nCachedTokens > 0) {\n            this.logger().warn('Embeddings: KV cache is not empty, this may produce incorrect results');\n        }\n        if (this.nCachedTokens + tokens.length > this.loadedContextInfo.n_ctx) {\n            throw new WllamaError('Running out of context cache. Please increase n_ctx when loading the model', 'kv_cache_full');\n        }\n        if (tokens.length > this.loadedContextInfo.n_batch) {\n            throw new WllamaError('Embedding tokens does not fit into batch. Please increase n_batch when loading the model', 'inference_error');\n        }\n        if (tokens.length > this.loadedContextInfo.n_ubatch) {\n            throw new WllamaError('Embedding tokens does not fit into physical batch. Please increase n_ubatch when loading the model', 'inference_error');\n        }\n        const result = await this.proxy.wllamaAction('embeddings', {\n            _name: 'gemb_req',\n            tokens,\n        });\n        if (!result.success) {\n            throw new WllamaError('embeddings unknown error');\n        }\n        else {\n            return result.embeddings;\n        }\n    }\n    /**\n     * Remove and shift some tokens from KV cache.\n     * Keep n_keep, remove n_discard then shift the rest\n     * @param nKeep\n     * @param nDiscard\n     */\n    async kvRemove(nKeep, nDiscard) {\n        this.checkModelLoaded();\n        if (nDiscard === 0)\n            return;\n        const result = await this.proxy.wllamaAction('kv_remove', {\n            _name: 'kvcr_req',\n            n_keep: nKeep,\n            n_discard: nDiscard,\n        });\n        if (!result.success) {\n            throw new WllamaError('kvRemove unknown error');\n        }\n        this.nCachedTokens -= nDiscard;\n    }\n    /**\n     * Clear all tokens in KV cache\n     */\n    async kvClear() {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('kv_clear', {\n            _name: 'kvcc_req',\n        });\n        if (!result.success) {\n            throw new WllamaError('kvClear unknown error');\n        }\n        this.nCachedTokens = 0;\n    }\n    /**\n     * Save session to file (virtual file system)\n     * TODO: add ability to download the file\n     * @param filePath\n     * @returns List of tokens saved to the file\n     */\n    // async sessionSave(filePath: string): Promise<{ tokens: number[] }> {\n    //   this.checkModelLoaded();\n    //   const result = await this.proxy.wllamaAction('session_save', {\n    //     session_path: filePath,\n    //   });\n    //   return result;\n    // }\n    /**\n     * Load session from file (virtual file system)\n     * TODO: add ability to download the file\n     * @param filePath\n     */\n    // async sessionLoad(filePath: string): Promise<void> {\n    //   this.checkModelLoaded();\n    //   const result = await this.proxy.wllamaAction('session_load', {\n    //     session_path: filePath,\n    //   });\n    //   if (result.error) {\n    //     throw new WllamaError(result.error);\n    //   } else if (!result.success) {\n    //     throw new WllamaError('sessionLoad unknown error');\n    //   }\n    //   const cachedTokens = await this.getCachedTokens();\n    //   this.nCachedTokens = cachedTokens.length;\n    // }\n    /**\n     * Apply chat template to a list of messages\n     *\n     * @param messages list of messages\n     * @param addAssistant whether to add assistant prompt at the end\n     * @param template (optional) custom template, see llama-server --chat-template argument for more details\n     * @returns formatted chat\n     */\n    async formatChat(messages, addAssistant, template) {\n        this.checkModelLoaded();\n        const roles = messages.map((m) => m.role);\n        const contents = messages.map((m) => m.content);\n        const result = await this.proxy.wllamaAction('chat_format', {\n            _name: 'cfmt_req',\n            roles,\n            contents,\n            tmpl: template,\n            add_ass: addAssistant,\n        });\n        if (!result.success) {\n            throw new WllamaError('formatChat unknown error');\n        }\n        return result.formatted_chat;\n    }\n    /**\n     * Set options for underlaying llama_context\n     */\n    async setOptions(opt) {\n        this.checkModelLoaded();\n        await this.proxy.wllamaAction('set_options', {\n            _name: 'opti_req',\n            ...opt,\n        });\n        this.useEmbeddings = opt.embeddings;\n    }\n    /**\n     * Unload the model and free all memory.\n     *\n     * Note: This function will NOT crash if model is not yet loaded\n     */\n    async exit() {\n        await this.proxy?.wllamaExit();\n        this.proxy = null;\n    }\n    /**\n     * get debug info\n     */\n    async _getDebugInfo() {\n        this.checkModelLoaded();\n        return await this.proxy.wllamaDebug();\n    }\n    /**\n     * benchmark function, only used internally\n     */\n    async _testBenchmark(type, nSamples) {\n        this.checkModelLoaded();\n        return await this.proxy.wllamaAction('test_benchmark', {\n            _name: 'tben_req',\n            type,\n            n_samples: nSamples,\n        });\n    }\n    /**\n     * perplexity function, only used internally\n     */\n    async _testPerplexity(tokens) {\n        this.checkModelLoaded();\n        return await this.proxy.wllamaAction('test_perplexity', {\n            _name: 'tper_req',\n            tokens,\n        });\n    }\n    ///// Prompt cache utils /////\n    async getCachedTokens() {\n        this.checkModelLoaded();\n        const result = await this.proxy.wllamaAction('current_status', {\n            _name: 'stat_req',\n        });\n        return result.tokens;\n    }\n    /**\n     * Compare the input sequence and cachedToken, then return the part that is not in cache.\n     * This function also remove mismatch part in cache (via kvRemove)\n     */\n    async computeNonCachedTokens(seq) {\n        const cachedTokens = await this.getCachedTokens();\n        let nKeep = 0;\n        for (; nKeep < Math.min(cachedTokens.length, seq.length); nKeep++) {\n            if (cachedTokens[nKeep] !== seq[nKeep]) {\n                break;\n            }\n        }\n        this.logger().debug(`Cache nKeep=${nKeep}`);\n        await this.kvRemove(nKeep, -1);\n        return seq.slice(nKeep, seq.length);\n    }\n}\n//# sourceMappingURL=wllama.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/wllama.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/worker.js":
/*!***************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/worker.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProxyToWorker: () => (/* binding */ ProxyToWorker)\n/* harmony export */ });\n/* harmony import */ var _glue_glue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glue/glue.js */ \"./node_modules/@wllama/wllama/esm/glue/glue.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@wllama/wllama/esm/utils.js\");\n/* harmony import */ var _workers_code_generated_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./workers-code/generated.js */ \"./node_modules/@wllama/wllama/esm/workers-code/generated.js\");\n/**\n * Module code will be copied into worker.\n *\n * Messages between main <==> worker:\n *\n * From main thread to worker:\n * - Send direction: { verb, args, callbackId }\n * - Result direction: { callbackId, result } or { callbackId, err }\n *\n * Signal from worker to main:\n * - Unidirection: { verb, args }\n */\n\n\n\nclass ProxyToWorker {\n    logger;\n    suppressNativeLog;\n    taskQueue = [];\n    taskId = 1;\n    resultQueue = [];\n    busy = false; // is the work loop is running?\n    worker;\n    pathConfig;\n    multiThread;\n    nbThread;\n    constructor(pathConfig, nbThread = 1, suppressNativeLog, logger) {\n        this.pathConfig = pathConfig;\n        this.nbThread = nbThread;\n        this.multiThread = nbThread > 1;\n        this.logger = logger;\n        this.suppressNativeLog = suppressNativeLog;\n    }\n    async moduleInit(ggufFiles) {\n        if (!this.pathConfig['wllama.wasm']) {\n            throw new Error('\"single-thread/wllama.wasm\" is missing from pathConfig');\n        }\n        let moduleCode = this.multiThread\n            ? _workers_code_generated_js__WEBPACK_IMPORTED_MODULE_2__.WLLAMA_MULTI_THREAD_CODE\n            : _workers_code_generated_js__WEBPACK_IMPORTED_MODULE_2__.WLLAMA_SINGLE_THREAD_CODE;\n        moduleCode = moduleCode.replace('var Module', 'var ___Module');\n        const runOptions = {\n            pathConfig: this.pathConfig,\n            nbThread: this.nbThread,\n        };\n        const completeCode = [\n            this.multiThread\n                ? `const WLLAMA_MULTI_THREAD_WORKER_CODE = ${JSON.stringify(_workers_code_generated_js__WEBPACK_IMPORTED_MODULE_2__.WLLAMA_MULTI_THREAD_WORKER_CODE)};`\n                : '// single-thread build',\n            `const RUN_OPTIONS = ${JSON.stringify(runOptions)};`,\n            `function wModuleInit() { ${moduleCode}; return Module; }`,\n            _workers_code_generated_js__WEBPACK_IMPORTED_MODULE_2__.LLAMA_CPP_WORKER_CODE,\n        ].join(';\\n\\n');\n        this.worker = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createWorker)(completeCode);\n        this.worker.onmessage = this.onRecvMsg.bind(this);\n        this.worker.onerror = this.logger.error;\n        const res = await this.pushTask({\n            verb: 'module.init',\n            args: [new Blob([moduleCode], { type: 'text/javascript' })],\n            callbackId: this.taskId++,\n        });\n        // allocate all files\n        const nativeFiles = [];\n        for (const file of ggufFiles) {\n            const id = await this.fileAlloc(file.name, file.blob.size);\n            nativeFiles.push({ id, ...file });\n        }\n        // stream files\n        await Promise.all(nativeFiles.map((file) => {\n            return this.fileWrite(file.id, file.blob);\n        }));\n        return res;\n    }\n    async wllamaStart() {\n        const result = await this.pushTask({\n            verb: 'wllama.start',\n            args: [],\n            callbackId: this.taskId++,\n        });\n        const parsedResult = this.parseResult(result);\n        return parsedResult;\n    }\n    async wllamaAction(name, body) {\n        const encodedMsg = (0,_glue_glue_js__WEBPACK_IMPORTED_MODULE_0__.glueSerialize)(body);\n        const result = await this.pushTask({\n            verb: 'wllama.action',\n            args: [name, encodedMsg],\n            callbackId: this.taskId++,\n        });\n        const parsedResult = (0,_glue_glue_js__WEBPACK_IMPORTED_MODULE_0__.glueDeserialize)(result);\n        return parsedResult;\n    }\n    async wllamaExit() {\n        if (this.worker) {\n            const result = await this.pushTask({\n                verb: 'wllama.exit',\n                args: [],\n                callbackId: this.taskId++,\n            });\n            this.parseResult(result); // only check for exceptions\n            this.worker.terminate();\n        }\n    }\n    async wllamaDebug() {\n        const result = await this.pushTask({\n            verb: 'wllama.debug',\n            args: [],\n            callbackId: this.taskId++,\n        });\n        return JSON.parse(result);\n    }\n    ///////////////////////////////////////\n    /**\n     * Allocate a new file in heapfs\n     * @returns fileId, to be used by fileWrite()\n     */\n    async fileAlloc(fileName, size) {\n        const result = await this.pushTask({\n            verb: 'fs.alloc',\n            args: [fileName, size],\n            callbackId: this.taskId++,\n        });\n        return result.fileId;\n    }\n    /**\n     * Write a Blob to heapfs\n     */\n    async fileWrite(fileId, blob) {\n        const reader = blob.stream().getReader();\n        let offset = 0;\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done)\n                break;\n            const size = value.byteLength;\n            await this.pushTask({\n                verb: 'fs.write',\n                args: [fileId, value, offset],\n                callbackId: this.taskId++,\n            }, \n            // @ts-ignore Type 'ArrayBufferLike' is not assignable to type 'ArrayBuffer'\n            [value.buffer]);\n            offset += size;\n        }\n    }\n    /**\n     * Parse JSON result returned by cpp code.\n     * Throw new Error if \"__exception\" is present in the response\n     *\n     * TODO: get rid of this function once everything is migrated to Glue\n     */\n    parseResult(result) {\n        const parsedResult = JSON.parse(result);\n        if (parsedResult && parsedResult['error']) {\n            throw new Error('Unknown error, please see console.log');\n        }\n        return parsedResult;\n    }\n    /**\n     * Push a new task to taskQueue\n     */\n    pushTask(param, buffers) {\n        return new Promise((resolve, reject) => {\n            this.taskQueue.push({ resolve, reject, param, buffers });\n            this.runTaskLoop();\n        });\n    }\n    /**\n     * Main loop for processing tasks\n     */\n    async runTaskLoop() {\n        if (this.busy) {\n            return; // another loop is already running\n        }\n        this.busy = true;\n        while (true) {\n            const task = this.taskQueue.shift();\n            if (!task)\n                break; // no more tasks\n            this.resultQueue.push(task);\n            // TODO @ngxson : Safari mobile doesn't support transferable ArrayBuffer\n            this.worker.postMessage(task.param, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isSafariMobile)()\n                ? undefined\n                : {\n                    transfer: task.buffers ?? [],\n                });\n        }\n        this.busy = false;\n    }\n    /**\n     * Handle messages from worker\n     */\n    onRecvMsg(e) {\n        if (!e.data)\n            return; // ignore\n        const { verb, args } = e.data;\n        if (verb && verb.startsWith('console.')) {\n            if (this.suppressNativeLog) {\n                return;\n            }\n            if (verb.endsWith('debug'))\n                this.logger.debug(...args);\n            if (verb.endsWith('log'))\n                this.logger.log(...args);\n            if (verb.endsWith('warn'))\n                this.logger.warn(...args);\n            if (verb.endsWith('error'))\n                this.logger.error(...args);\n            return;\n        }\n        else if (verb === 'signal.abort') {\n            this.abort(args[0]);\n        }\n        const { callbackId, result, err } = e.data;\n        if (callbackId) {\n            const idx = this.resultQueue.findIndex((t) => t.param.callbackId === callbackId);\n            if (idx !== -1) {\n                const waitingTask = this.resultQueue.splice(idx, 1)[0];\n                if (err)\n                    waitingTask.reject(err);\n                else\n                    waitingTask.resolve(result);\n            }\n            else {\n                this.logger.error(`Cannot find waiting task with callbackId = ${callbackId}`);\n            }\n        }\n    }\n    abort(text) {\n        while (this.resultQueue.length > 0) {\n            const waitingTask = this.resultQueue.pop();\n            if (!waitingTask)\n                break;\n            waitingTask.reject(new Error(`Received abort signal from llama.cpp; Message: ${text || '(empty)'}`));\n        }\n    }\n}\n//# sourceMappingURL=worker.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/worker.js?");

/***/ }),

/***/ "./node_modules/@wllama/wllama/esm/workers-code/generated.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@wllama/wllama/esm/workers-code/generated.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLAMA_CPP_WORKER_CODE: () => (/* binding */ LLAMA_CPP_WORKER_CODE),\n/* harmony export */   OPFS_UTILS_WORKER_CODE: () => (/* binding */ OPFS_UTILS_WORKER_CODE),\n/* harmony export */   WLLAMA_MULTI_THREAD_CODE: () => (/* binding */ WLLAMA_MULTI_THREAD_CODE),\n/* harmony export */   WLLAMA_MULTI_THREAD_WORKER_CODE: () => (/* binding */ WLLAMA_MULTI_THREAD_WORKER_CODE),\n/* harmony export */   WLLAMA_SINGLE_THREAD_CODE: () => (/* binding */ WLLAMA_SINGLE_THREAD_CODE)\n/* harmony export */ });\n// This file is auto-generated\n// To re-generate it, run: npm run build:worker\nconst LLAMA_CPP_WORKER_CODE = \"// Start the main llama.cpp\\nlet wllamaMalloc;\\nlet wllamaStart;\\nlet wllamaAction;\\nlet wllamaExit;\\nlet wllamaDebug;\\n\\nlet Module = null;\\n\\n//////////////////////////////////////////////////////////////\\n// UTILS\\n//////////////////////////////////////////////////////////////\\n\\n// send message back to main thread\\nconst msg = (data, transfer) => postMessage(data, transfer);\\n\\n// Convert CPP log into JS log\\nconst cppLogToJSLog = (line) => {\\n  const matched = line.match(/@@(DEBUG|INFO|WARN|ERROR)@@(.*)/);\\n  return !!matched\\n    ? {\\n        level: (matched[1] === 'INFO' ? 'debug' : matched[1]).toLowerCase(),\\n        text: matched[2],\\n      }\\n    : { level: 'log', text: line };\\n};\\n\\n// Get module config that forwards stdout/err to main thread\\nconst getWModuleConfig = (_argMainScriptBlob) => {\\n  var pathConfig = RUN_OPTIONS.pathConfig;\\n  var pthreadPoolSize = RUN_OPTIONS.nbThread;\\n  var argMainScriptBlob = _argMainScriptBlob;\\n\\n  if (!pathConfig['wllama.wasm']) {\\n    throw new Error('\\\"wllama.wasm\\\" is missing in pathConfig');\\n  }\\n  return {\\n    noInitialRun: true,\\n    print: function (text) {\\n      if (arguments.length > 1)\\n        text = Array.prototype.slice.call(arguments).join(' ');\\n      msg({ verb: 'console.log', args: [text] });\\n    },\\n    printErr: function (text) {\\n      if (arguments.length > 1)\\n        text = Array.prototype.slice.call(arguments).join(' ');\\n      const logLine = cppLogToJSLog(text);\\n      msg({ verb: 'console.' + logLine.level, args: [logLine.text] });\\n    },\\n    locateFile: function (filename, basePath) {\\n      const p = pathConfig[filename];\\n      const truncate = (str) =>\\n        str.length > 128 ? `${str.substr(0, 128)}...` : str;\\n      if (filename.match(/wllama\\\\.worker\\\\.js/)) {\\n        msg({\\n          verb: 'console.debug',\\n          args: [`Loading \\\"${filename}\\\" from WLLAMA_MULTI_THREAD_WORKER_CODE`],\\n        });\\n        const workerURL = URL.createObjectURL(\\n          new Blob([WLLAMA_MULTI_THREAD_WORKER_CODE], {\\n            type: 'text/javascript',\\n          })\\n        );\\n        return workerURL.toString();\\n      } else {\\n        msg({\\n          verb: 'console.debug',\\n          args: [`Loading \\\"${filename}\\\" from \\\"${truncate(p)}\\\"`],\\n        });\\n        return p;\\n      }\\n    },\\n    mainScriptUrlOrBlob: argMainScriptBlob,\\n    pthreadPoolSize,\\n    wasmMemory: pthreadPoolSize > 1 ? getWasmMemory() : null,\\n    onAbort: function (text) {\\n      msg({ verb: 'signal.abort', args: [text] });\\n    },\\n  };\\n};\\n\\n// Get the memory to be used by wasm. (Only used in multi-thread mode)\\n// Because we have a weird OOM issue on iOS, we need to try some values\\n// See: https://github.com/emscripten-core/emscripten/issues/19144\\n//      https://github.com/godotengine/godot/issues/70621\\nconst getWasmMemory = () => {\\n  let minBytes = 128 * 1024 * 1024;\\n  let maxBytes = 4096 * 1024 * 1024;\\n  let stepBytes = 128 * 1024 * 1024;\\n  while (maxBytes > minBytes) {\\n    try {\\n      const wasmMemory = new WebAssembly.Memory({\\n        initial: minBytes / 65536,\\n        maximum: maxBytes / 65536,\\n        shared: true,\\n      });\\n      return wasmMemory;\\n    } catch (e) {\\n      maxBytes -= stepBytes;\\n      continue; // retry\\n    }\\n  }\\n  throw new Error('Cannot allocate WebAssembly.Memory');\\n};\\n\\n//////////////////////////////////////////////////////////////\\n// MEMFS PATCH\\n//////////////////////////////////////////////////////////////\\n\\n/**\\n * By default, emscripten uses memfs. The way it works is by\\n * allocating new Uint8Array in javascript heap. This is not good\\n * because it requires files to be copied to wasm heap each time\\n * a file is read.\\n *\\n * HeapFS is an alternative, which resolves this problem by\\n * allocating space for file directly inside wasm heap. This\\n * allows us to mmap without doing any copy.\\n *\\n * For llama.cpp, this is great because we use MAP_SHARED\\n *\\n * Ref: https://github.com/ngxson/wllama/pull/39\\n * Ref: https://github.com/emscripten-core/emscripten/blob/main/src/library_memfs.js\\n *\\n * Note 29/05/2024 @ngxson\\n * Due to ftell() being limited to MAX_LONG, we cannot load files bigger than 2^31 bytes (or 2GB)\\n * Ref: https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/src/stdio/ftell.c\\n */\\n\\nconst fsNameToFile = {}; // map Name => File\\nconst fsIdToFile = {}; // map ID => File\\nlet currFileId = 0;\\n\\n// Patch and redirect memfs calls to wllama\\nconst patchMEMFS = () => {\\n  const m = Module;\\n  // save functions\\n  m.MEMFS.stream_ops._read = m.MEMFS.stream_ops.read;\\n  m.MEMFS.stream_ops._write = m.MEMFS.stream_ops.write;\\n  m.MEMFS.stream_ops._llseek = m.MEMFS.stream_ops.llseek;\\n  m.MEMFS.stream_ops._allocate = m.MEMFS.stream_ops.allocate;\\n  m.MEMFS.stream_ops._mmap = m.MEMFS.stream_ops.mmap;\\n  m.MEMFS.stream_ops._msync = m.MEMFS.stream_ops.msync;\\n\\n  const patchStream = (stream) => {\\n    const name = stream.node.name;\\n    if (fsNameToFile[name]) {\\n      const f = fsNameToFile[name];\\n      stream.node.contents = m.HEAPU8.subarray(f.ptr, f.ptr + f.size);\\n      stream.node.usedBytes = f.size;\\n    }\\n  };\\n\\n  // replace \\\"read\\\" functions\\n  m.MEMFS.stream_ops.read = function (\\n    stream,\\n    buffer,\\n    offset,\\n    length,\\n    position\\n  ) {\\n    patchStream(stream);\\n    return m.MEMFS.stream_ops._read(stream, buffer, offset, length, position);\\n  };\\n  m.MEMFS.ops_table.file.stream.read = m.MEMFS.stream_ops.read;\\n\\n  // replace \\\"llseek\\\" functions\\n  m.MEMFS.stream_ops.llseek = function (stream, offset, whence) {\\n    patchStream(stream);\\n    return m.MEMFS.stream_ops._llseek(stream, offset, whence);\\n  };\\n  m.MEMFS.ops_table.file.stream.llseek = m.MEMFS.stream_ops.llseek;\\n\\n  // replace \\\"mmap\\\" functions\\n  m.MEMFS.stream_ops.mmap = function (stream, length, position, prot, flags) {\\n    patchStream(stream);\\n    const name = stream.node.name;\\n    if (fsNameToFile[name]) {\\n      const f = fsNameToFile[name];\\n      return {\\n        ptr: f.ptr + position,\\n        allocated: false,\\n      };\\n    } else {\\n      return m.MEMFS.stream_ops._mmap(stream, length, position, prot, flags);\\n    }\\n  };\\n  m.MEMFS.ops_table.file.stream.mmap = m.MEMFS.stream_ops.mmap;\\n\\n  // mount FS\\n  m.FS.mkdir('/models');\\n  m.FS.mount(m.MEMFS, { root: '.' }, '/models');\\n};\\n\\n// Allocate a new file in wllama heapfs, returns file ID\\nconst heapfsAlloc = (name, size) => {\\n  if (size < 1) {\\n    throw new Error('File size must be bigger than 0');\\n  }\\n  const m = Module;\\n  const ptr = m.mmapAlloc(size);\\n  const file = {\\n    ptr: ptr,\\n    size: size,\\n    id: currFileId++,\\n  };\\n  fsIdToFile[file.id] = file;\\n  fsNameToFile[name] = file;\\n  return file.id;\\n};\\n\\n// Add new file to wllama heapfs, return number of written bytes\\nconst heapfsWrite = (id, buffer, offset) => {\\n  const m = Module;\\n  if (fsIdToFile[id]) {\\n    const { ptr, size } = fsIdToFile[id];\\n    const afterWriteByte = offset + buffer.byteLength;\\n    if (afterWriteByte > size) {\\n      throw new Error(\\n        `File ID ${id} write out of bound, afterWriteByte = ${afterWriteByte} while size = ${size}`\\n      );\\n    }\\n    m.HEAPU8.set(buffer, ptr + offset);\\n    return buffer.byteLength;\\n  } else {\\n    throw new Error(`File ID ${id} not found in heapfs`);\\n  }\\n};\\n\\n//////////////////////////////////////////////////////////////\\n// MAIN CODE\\n//////////////////////////////////////////////////////////////\\n\\nconst callWrapper = (name, ret, args) => {\\n  const fn = Module.cwrap(name, ret, args);\\n  return async (action, req) => {\\n    let result;\\n    try {\\n      if (args.length === 2) {\\n        result = await fn(action, req);\\n      } else {\\n        result = fn();\\n      }\\n    } catch (ex) {\\n      console.error(ex);\\n      throw ex;\\n    }\\n    return result;\\n  };\\n};\\n\\nonmessage = async (e) => {\\n  if (!e.data) return;\\n  const { verb, args, callbackId } = e.data;\\n\\n  if (!callbackId) {\\n    msg({ verb: 'console.error', args: ['callbackId is required', e.data] });\\n    return;\\n  }\\n\\n  if (verb === 'module.init') {\\n    const argMainScriptBlob = args[0];\\n    try {\\n      Module = getWModuleConfig(argMainScriptBlob);\\n      Module.onRuntimeInitialized = () => {\\n        // async call once module is ready\\n        // init FS\\n        patchMEMFS();\\n        // init cwrap\\n        const pointer = 'number';\\n        // TODO: note sure why emscripten cannot bind if there is only 1 argument\\n        wllamaMalloc = callWrapper('wllama_malloc', pointer, [\\n          'number',\\n          pointer,\\n        ]);\\n        wllamaStart = callWrapper('wllama_start', 'string', []);\\n        wllamaAction = callWrapper('wllama_action', pointer, [\\n          'string',\\n          pointer,\\n        ]);\\n        wllamaExit = callWrapper('wllama_exit', 'string', []);\\n        wllamaDebug = callWrapper('wllama_debug', 'string', []);\\n        msg({ callbackId, result: null });\\n      };\\n      wModuleInit();\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'fs.alloc') {\\n    const argFilename = args[0];\\n    const argSize = args[1];\\n    try {\\n      // create blank file\\n      const emptyBuffer = new ArrayBuffer(0);\\n      Module['FS_createDataFile'](\\n        '/models',\\n        argFilename,\\n        emptyBuffer,\\n        true,\\n        true,\\n        true\\n      );\\n      // alloc data on heap\\n      const fileId = heapfsAlloc(argFilename, argSize);\\n      msg({ callbackId, result: { fileId } });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'fs.write') {\\n    const argFileId = args[0];\\n    const argBuffer = args[1];\\n    const argOffset = args[2];\\n    try {\\n      const writtenBytes = heapfsWrite(argFileId, argBuffer, argOffset);\\n      msg({ callbackId, result: { writtenBytes } });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.start') {\\n    try {\\n      const result = await wllamaStart();\\n      msg({ callbackId, result });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.action') {\\n    const argAction = args[0];\\n    const argEncodedMsg = args[1];\\n    try {\\n      const inputPtr = await wllamaMalloc(argEncodedMsg.byteLength, 0);\\n      // copy data to wasm heap\\n      const inputBuffer = new Uint8Array(\\n        Module.HEAPU8.buffer,\\n        inputPtr,\\n        argEncodedMsg.byteLength\\n      );\\n      inputBuffer.set(argEncodedMsg, 0);\\n      const outputPtr = await wllamaAction(argAction, inputPtr);\\n      // length of output buffer is written at the first 4 bytes of input buffer\\n      const outputLen = new Uint32Array(Module.HEAPU8.buffer, inputPtr, 1)[0];\\n      // copy the output buffer to JS heap\\n      const outputBuffer = new Uint8Array(outputLen);\\n      const outputSrcView = new Uint8Array(\\n        Module.HEAPU8.buffer,\\n        outputPtr,\\n        outputLen\\n      );\\n      outputBuffer.set(outputSrcView, 0); // copy it\\n      msg({ callbackId, result: outputBuffer }, [outputBuffer.buffer]);\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.exit') {\\n    try {\\n      const result = await wllamaExit();\\n      msg({ callbackId, result });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.debug') {\\n    try {\\n      const result = await wllamaDebug();\\n      msg({ callbackId, result });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n};\\n\";\nconst OPFS_UTILS_WORKER_CODE = \"let accessHandle;\\nlet abortController = new AbortController();\\n\\nasync function openFile(filename) {\\n  const opfsRoot = await navigator.storage.getDirectory();\\n  const cacheDir = await opfsRoot.getDirectoryHandle('cache', { create: true });\\n  const fileHandler = await cacheDir.getFileHandle(filename, { create: true });\\n  accessHandle = await fileHandler.createSyncAccessHandle();\\n  accessHandle.truncate(0); // clear file content\\n}\\n\\nasync function writeFile(buf) {\\n  accessHandle.write(buf);\\n}\\n\\nasync function closeFile() {\\n  accessHandle.flush();\\n  accessHandle.close();\\n}\\n\\nasync function writeTextFile(filename, str) {\\n  await openFile(filename);\\n  await writeFile(new TextEncoder().encode(str));\\n  await closeFile();\\n}\\n\\nconst throttled = (func, delay) => {\\n  let lastRun = 0;\\n  return (...args) => {\\n    const now = Date.now();\\n    if (now - lastRun > delay) {\\n      lastRun = now;\\n      func.apply(null, args);\\n    }\\n  };\\n};\\n\\nconst assertNonNull = (val) => {\\n  if (val === null || val === undefined) {\\n    throw new Error('OPFS Worker: Assertion failed');\\n  }\\n};\\n\\n// respond to main thread\\nconst resOK = () => postMessage({ ok: true });\\nconst resProgress = (loaded, total) =>\\n  postMessage({ progress: { loaded, total } });\\nconst resErr = (err) => postMessage({ err });\\n\\nonmessage = async (e) => {\\n  try {\\n    if (!e.data) return;\\n\\n    /**\\n     * @param {Object} e.data\\n     *\\n     * Fine-control FS actions:\\n     * - { action: 'open', filename: 'string' }\\n     * - { action: 'write', buf: ArrayBuffer }\\n     * - { action: 'close' }\\n     *\\n     * Simple write API:\\n     * - { action: 'write-simple', filename: 'string', buf: ArrayBuffer }\\n     *\\n     * Download API:\\n     * - { action: 'download', url: 'string', filename: 'string', options: Object, metadataFileName: 'string' }\\n     * - { action: 'download-abort' }\\n     */\\n    const { action, filename, buf, url, options, metadataFileName } = e.data;\\n\\n    if (action === 'open') {\\n      assertNonNull(filename);\\n      await openFile(filename);\\n      return resOK();\\n    } else if (action === 'write') {\\n      assertNonNull(buf);\\n      await writeFile(buf);\\n      return resOK();\\n    } else if (action === 'close') {\\n      await closeFile();\\n      return resOK();\\n    } else if (action === 'write-simple') {\\n      assertNonNull(filename);\\n      assertNonNull(buf);\\n      await openFile(filename);\\n      await writeFile(buf);\\n      await closeFile();\\n      return resOK();\\n    } else if (action === 'download') {\\n      assertNonNull(url);\\n      assertNonNull(filename);\\n      assertNonNull(metadataFileName);\\n      assertNonNull(options);\\n      assertNonNull(options.aborted);\\n      abortController = new AbortController();\\n      if (options.aborted) abortController.abort();\\n      const response = await fetch(url, {\\n        ...options,\\n        signal: abortController.signal,\\n      });\\n      const contentLength = response.headers.get('content-length');\\n      const etag = (response.headers.get('etag') || '').replace(\\n        /[^A-Za-z0-9]/g,\\n        ''\\n      );\\n      const total = parseInt(contentLength, 10);\\n      const reader = response.body.getReader();\\n      await openFile(filename);\\n      let loaded = 0;\\n      const throttledProgress = throttled(resProgress, 100);\\n      while (true) {\\n        const { done, value } = await reader.read();\\n        if (done) break;\\n        loaded += value.byteLength;\\n        await writeFile(value);\\n        throttledProgress(loaded, total);\\n      }\\n      resProgress(total, total); // 100% done\\n      await closeFile();\\n      // make sure this is in-sync with CacheEntryMetadata\\n      await writeTextFile(\\n        metadataFileName,\\n        JSON.stringify({\\n          originalURL: url,\\n          originalSize: total,\\n          etag,\\n        })\\n      );\\n      return resOK();\\n    } else if (action === 'download-abort') {\\n      if (abortController) {\\n        abortController.abort();\\n      }\\n      return;\\n    }\\n\\n    throw new Error('OPFS Worker: Invalid action', e.data);\\n  } catch (err) {\\n    return resErr(err);\\n  }\\n};\\n\";\nconst WLLAMA_MULTI_THREAD_CODE = \"function GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU8}function GROWABLE_HEAP_I16(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP16}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPF64}var Module=typeof Module!=\\\"undefined\\\"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\\\"./this.program\\\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window==\\\"object\\\";var ENVIRONMENT_IS_WORKER=typeof importScripts==\\\"function\\\";var ENVIRONMENT_IS_NODE=typeof process==\\\"object\\\"&&typeof process.versions==\\\"object\\\"&&typeof process.versions.node==\\\"string\\\";var ENVIRONMENT_IS_PTHREAD=Module[\\\"ENVIRONMENT_IS_PTHREAD\\\"]||false;var _scriptDir=typeof document!=\\\"undefined\\\"&&document.currentScript?document.currentScript.src:undefined;if(ENVIRONMENT_IS_WORKER){_scriptDir=self.location.href}else if(ENVIRONMENT_IS_NODE){_scriptDir=__filename}var scriptDirectory=\\\"\\\";function locateFile(path){if(Module[\\\"locateFile\\\"]){return Module[\\\"locateFile\\\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;if(ENVIRONMENT_IS_NODE){var fs=require(\\\"fs\\\");var nodePath=require(\\\"path\\\");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+\\\"/\\\"}else{scriptDirectory=__dirname+\\\"/\\\"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:\\\"utf8\\\")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:\\\"utf8\\\",(err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)})};if(!Module[\\\"thisProgram\\\"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")}arguments_=process.argv.slice(2);if(typeof module!=\\\"undefined\\\"){module[\\\"exports\\\"]=Module}process.on(\\\"uncaughtException\\\",ex=>{if(ex!==\\\"unwind\\\"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}});quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};global.Worker=require(\\\"worker_threads\\\").Worker}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\\\"undefined\\\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.startsWith(\\\"blob:\\\")){scriptDirectory=\\\"\\\"}else{scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1)}if(!ENVIRONMENT_IS_NODE){read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);xhr.responseType=\\\"arraybuffer\\\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,true);xhr.responseType=\\\"arraybuffer\\\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}}else{}if(ENVIRONMENT_IS_NODE){if(typeof performance==\\\"undefined\\\"){global.performance=require(\\\"perf_hooks\\\").performance}}var defaultPrint=console.log.bind(console);var defaultPrintErr=console.error.bind(console);if(ENVIRONMENT_IS_NODE){defaultPrint=(...args)=>fs.writeSync(1,args.join(\\\" \\\")+\\\"\\\\n\\\");defaultPrintErr=(...args)=>fs.writeSync(2,args.join(\\\" \\\")+\\\"\\\\n\\\")}var out=Module[\\\"print\\\"]||defaultPrint;var err=Module[\\\"printErr\\\"]||defaultPrintErr;Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\\\"arguments\\\"])arguments_=Module[\\\"arguments\\\"];if(Module[\\\"thisProgram\\\"])thisProgram=Module[\\\"thisProgram\\\"];if(Module[\\\"quit\\\"])quit_=Module[\\\"quit\\\"];var wasmBinary;if(Module[\\\"wasmBinary\\\"])wasmBinary=Module[\\\"wasmBinary\\\"];if(typeof WebAssembly!=\\\"object\\\"){abort(\\\"no native wasm support detected\\\")}var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module[\\\"HEAP8\\\"]=HEAP8=new Int8Array(b);Module[\\\"HEAP16\\\"]=HEAP16=new Int16Array(b);Module[\\\"HEAPU8\\\"]=HEAPU8=new Uint8Array(b);Module[\\\"HEAPU16\\\"]=HEAPU16=new Uint16Array(b);Module[\\\"HEAP32\\\"]=HEAP32=new Int32Array(b);Module[\\\"HEAPU32\\\"]=HEAPU32=new Uint32Array(b);Module[\\\"HEAPF32\\\"]=HEAPF32=new Float32Array(b);Module[\\\"HEAPF64\\\"]=HEAPF64=new Float64Array(b)}var INITIAL_MEMORY=Module[\\\"INITIAL_MEMORY\\\"]||134217728;if(ENVIRONMENT_IS_PTHREAD){wasmMemory=Module[\\\"wasmMemory\\\"]}else{if(Module[\\\"wasmMemory\\\"]){wasmMemory=Module[\\\"wasmMemory\\\"]}else{wasmMemory=new WebAssembly.Memory({\\\"initial\\\":INITIAL_MEMORY/65536,\\\"maximum\\\":4294967296/65536,\\\"shared\\\":true});if(!(wasmMemory.buffer instanceof SharedArrayBuffer)){err(\\\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\\\");if(ENVIRONMENT_IS_NODE){err(\\\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\\\")}throw Error(\\\"bad memory\\\")}}}updateMemoryViews();INITIAL_MEMORY=wasmMemory.buffer.byteLength;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module[\\\"preRun\\\"]){if(typeof Module[\\\"preRun\\\"]==\\\"function\\\")Module[\\\"preRun\\\"]=[Module[\\\"preRun\\\"]];while(Module[\\\"preRun\\\"].length){addOnPreRun(Module[\\\"preRun\\\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return;if(!Module[\\\"noFSInit\\\"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;TTY.init();callRuntimeCallbacks(__ATINIT__)}function preMain(){if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module[\\\"postRun\\\"]){if(typeof Module[\\\"postRun\\\"]==\\\"function\\\")Module[\\\"postRun\\\"]=[Module[\\\"postRun\\\"]];while(Module[\\\"postRun\\\"].length){addOnPostRun(Module[\\\"postRun\\\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies)}function removeRunDependency(id){runDependencies--;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){Module[\\\"onAbort\\\"]?.(what);what=\\\"Aborted(\\\"+what+\\\")\\\";err(what);ABORT=true;EXITSTATUS=1;what+=\\\". Build with -sASSERTIONS for more info.\\\";if(runtimeInitialized){___trap()}var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix=\\\"data:application/octet-stream;base64,\\\";var isDataURI=filename=>filename.startsWith(dataURIPrefix);var isFileURI=filename=>filename.startsWith(\\\"file://\\\");var wasmBinaryFile;wasmBinaryFile=\\\"wllama.wasm\\\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\\\"both async and sync fetching of the wasm failed\\\"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\\\"function\\\"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:\\\"same-origin\\\"}).then(response=>{if(!response[\\\"ok\\\"]){throw`failed to load wasm binary file at '${binaryFile}'`}return response[\\\"arrayBuffer\\\"]()}).catch(()=>getBinarySync(binaryFile))}else if(readAsync){return new Promise((resolve,reject)=>{readAsync(binaryFile,response=>resolve(new Uint8Array(response)),reject)})}}return Promise.resolve().then(()=>getBinarySync(binaryFile))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)})}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming==\\\"function\\\"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch==\\\"function\\\"){return fetch(binaryFile,{credentials:\\\"same-origin\\\"}).then(response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){err(`wasm streaming compile failed: ${reason}`);err(\\\"falling back to ArrayBuffer instantiation\\\");return instantiateArrayBuffer(binaryFile,imports,callback)})})}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={\\\"a\\\":wasmImports};function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=applySignatureConversions(wasmExports);registerTLSInit(wasmExports[\\\"K\\\"]);wasmTable=wasmExports[\\\"N\\\"];addOnInit(wasmExports[\\\"D\\\"]);wasmModule=module;removeRunDependency(\\\"wasm-instantiate\\\");return wasmExports}addRunDependency(\\\"wasm-instantiate\\\");function receiveInstantiationResult(result){receiveInstance(result[\\\"instance\\\"],result[\\\"module\\\"])}if(Module[\\\"instantiateWasm\\\"]){try{return Module[\\\"instantiateWasm\\\"](info,receiveInstance)}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}var tempDouble;var tempI64;function ExitStatus(status){this.name=\\\"ExitStatus\\\";this.message=`Program terminated with exit(${status})`;this.status=status}Module[\\\"ExitStatus\\\"]=ExitStatus;var terminateWorker=worker=>{worker.terminate();worker.onmessage=e=>{}};Module[\\\"terminateWorker\\\"]=terminateWorker;var killThread=pthread_ptr=>{var worker=PThread.pthreads[pthread_ptr];delete PThread.pthreads[pthread_ptr];terminateWorker(worker);__emscripten_thread_free_data(pthread_ptr);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0};Module[\\\"killThread\\\"]=killThread;var cancelThread=pthread_ptr=>{var worker=PThread.pthreads[pthread_ptr];worker.postMessage({\\\"cmd\\\":\\\"cancel\\\"})};Module[\\\"cancelThread\\\"]=cancelThread;var cleanupThread=pthread_ptr=>{var worker=PThread.pthreads[pthread_ptr];PThread.returnWorkerToPool(worker)};Module[\\\"cleanupThread\\\"]=cleanupThread;var zeroMemory=(address,size)=>{GROWABLE_HEAP_U8().fill(0,address,address+size);return address};Module[\\\"zeroMemory\\\"]=zeroMemory;var spawnThread=threadParams=>{var worker=PThread.getNewWorker();if(!worker){return 6}PThread.runningWorkers.push(worker);PThread.pthreads[threadParams.pthread_ptr]=worker;worker.pthread_ptr=threadParams.pthread_ptr;var msg={\\\"cmd\\\":\\\"run\\\",\\\"start_routine\\\":threadParams.startRoutine,\\\"arg\\\":threadParams.arg,\\\"pthread_ptr\\\":threadParams.pthread_ptr};if(ENVIRONMENT_IS_NODE){worker.unref()}worker.postMessage(msg,threadParams.transferList);return 0};Module[\\\"spawnThread\\\"]=spawnThread;var runtimeKeepaliveCounter=0;Module[\\\"runtimeKeepaliveCounter\\\"]=runtimeKeepaliveCounter;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;Module[\\\"keepRuntimeAlive\\\"]=keepRuntimeAlive;var withStackSave=f=>{var stack=stackSave();var ret=f();stackRestore(stack);return ret};Module[\\\"withStackSave\\\"]=withStackSave;var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;Module[\\\"convertI32PairToI53Checked\\\"]=convertI32PairToI53Checked;var proxyToMainThread=(funcIndex,emAsmAddr,sync,...callArgs)=>withStackSave(()=>{var serializedNumCallArgs=callArgs.length;var args=stackAlloc(serializedNumCallArgs*8);var b=args>>>3;for(var i=0;i<callArgs.length;i++){var arg=callArgs[i];GROWABLE_HEAP_F64()[b+i>>>0]=arg}return __emscripten_run_on_main_thread_js(funcIndex,emAsmAddr,serializedNumCallArgs,args,sync)});Module[\\\"proxyToMainThread\\\"]=proxyToMainThread;function _proc_exit(code){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(0,0,1,code);EXITSTATUS=code;if(!keepRuntimeAlive()){PThread.terminateAllThreads();Module[\\\"onExit\\\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))}Module[\\\"_proc_exit\\\"]=_proc_exit;var exitJS=(status,implicit)=>{EXITSTATUS=status;if(ENVIRONMENT_IS_PTHREAD){exitOnMainThread(status);throw\\\"unwind\\\"}_proc_exit(status)};Module[\\\"exitJS\\\"]=exitJS;var _exit=exitJS;Module[\\\"_exit\\\"]=_exit;var handleException=e=>{if(e instanceof ExitStatus||e==\\\"unwind\\\"){return EXITSTATUS}quit_(1,e)};Module[\\\"handleException\\\"]=handleException;var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init(){if(ENVIRONMENT_IS_PTHREAD){PThread.initWorker()}else{PThread.initMainThread()}},initMainThread(){var pthreadPoolSize=Module[\\\"pthreadPoolSize\\\"];while(pthreadPoolSize--){PThread.allocateUnusedWorker()}addOnPreRun(()=>{addRunDependency(\\\"loading-workers\\\");PThread.loadWasmModuleToAllWorkers(()=>removeRunDependency(\\\"loading-workers\\\"))})},initWorker(){noExitRuntime=false},setExitStatus:status=>EXITSTATUS=status,terminateAllThreads__deps:[\\\"$terminateWorker\\\"],terminateAllThreads:()=>{for(var worker of PThread.runningWorkers){terminateWorker(worker)}for(var worker of PThread.unusedWorkers){terminateWorker(worker)}PThread.unusedWorkers=[];PThread.runningWorkers=[];PThread.pthreads=[]},returnWorkerToPool:worker=>{var pthread_ptr=worker.pthread_ptr;delete PThread.pthreads[pthread_ptr];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0;__emscripten_thread_free_data(pthread_ptr)},receiveObjectTransfer(data){},threadInitTLS(){PThread.tlsInitFunctions.forEach(f=>f())},loadWasmModuleToWorker:worker=>new Promise(onFinishedLoading=>{worker.onmessage=e=>{var d=e[\\\"data\\\"];var cmd=d[\\\"cmd\\\"];if(d[\\\"targetThread\\\"]&&d[\\\"targetThread\\\"]!=_pthread_self()){var targetWorker=PThread.pthreads[d[\\\"targetThread\\\"]];if(targetWorker){targetWorker.postMessage(d,d[\\\"transferList\\\"])}else{err(`Internal error! Worker sent a message \\\"${cmd}\\\" to target pthread ${d[\\\"targetThread\\\"]}, but that thread no longer exists!`)}return}if(cmd===\\\"checkMailbox\\\"){checkMailbox()}else if(cmd===\\\"spawnThread\\\"){spawnThread(d)}else if(cmd===\\\"cleanupThread\\\"){cleanupThread(d[\\\"thread\\\"])}else if(cmd===\\\"killThread\\\"){killThread(d[\\\"thread\\\"])}else if(cmd===\\\"cancelThread\\\"){cancelThread(d[\\\"thread\\\"])}else if(cmd===\\\"loaded\\\"){worker.loaded=true;if(ENVIRONMENT_IS_NODE&&!worker.pthread_ptr){worker.unref()}onFinishedLoading(worker)}else if(cmd===\\\"alert\\\"){alert(`Thread ${d[\\\"threadId\\\"]}: ${d[\\\"text\\\"]}`)}else if(d.target===\\\"setimmediate\\\"){worker.postMessage(d)}else if(cmd===\\\"callHandler\\\"){Module[d[\\\"handler\\\"]](...d[\\\"args\\\"])}else if(cmd){err(`worker sent an unknown command ${cmd}`)}};worker.onerror=e=>{var message=\\\"worker sent an error!\\\";err(`${message} ${e.filename}:${e.lineno}: ${e.message}`);throw e};if(ENVIRONMENT_IS_NODE){worker.on(\\\"message\\\",data=>worker.onmessage({data:data}));worker.on(\\\"error\\\",e=>worker.onerror(e))}var handlers=[];var knownHandlers=[\\\"onExit\\\",\\\"onAbort\\\",\\\"print\\\",\\\"printErr\\\"];for(var handler of knownHandlers){if(Module.hasOwnProperty(handler)){handlers.push(handler)}}worker.postMessage({\\\"cmd\\\":\\\"load\\\",\\\"handlers\\\":handlers,\\\"urlOrBlob\\\":Module[\\\"mainScriptUrlOrBlob\\\"]||_scriptDir,\\\"wasmMemory\\\":wasmMemory,\\\"wasmModule\\\":wasmModule})}),loadWasmModuleToAllWorkers(onMaybeReady){if(ENVIRONMENT_IS_PTHREAD){return onMaybeReady()}let pthreadPoolReady=Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));pthreadPoolReady.then(onMaybeReady)},allocateUnusedWorker(){var worker;var pthreadMainJs=locateFile(\\\"wllama.worker.js\\\");worker=new Worker(pthreadMainJs);PThread.unusedWorkers.push(worker)},getNewWorker(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()}};Module[\\\"PThread\\\"]=PThread;var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};Module[\\\"callRuntimeCallbacks\\\"]=callRuntimeCallbacks;var establishStackSpace=()=>{var pthread_ptr=_pthread_self();var stackHigh=GROWABLE_HEAP_U32()[pthread_ptr+52>>>2>>>0];var stackSize=GROWABLE_HEAP_U32()[pthread_ptr+56>>>2>>>0];var stackLow=stackHigh-stackSize;_emscripten_stack_set_limits(stackHigh,stackLow);stackRestore(stackHigh)};Module[\\\"establishStackSpace\\\"]=establishStackSpace;function exitOnMainThread(returnCode){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(1,0,0,returnCode);_exit(returnCode)}Module[\\\"exitOnMainThread\\\"]=exitOnMainThread;function getValue(ptr,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":return GROWABLE_HEAP_I8()[ptr>>>0];case\\\"i8\\\":return GROWABLE_HEAP_I8()[ptr>>>0];case\\\"i16\\\":return GROWABLE_HEAP_I16()[ptr>>>1>>>0];case\\\"i32\\\":return GROWABLE_HEAP_I32()[ptr>>>2>>>0];case\\\"i64\\\":abort(\\\"to do getValue(i64) use WASM_BIGINT\\\");case\\\"float\\\":return GROWABLE_HEAP_F32()[ptr>>>2>>>0];case\\\"double\\\":return GROWABLE_HEAP_F64()[ptr>>>3>>>0];case\\\"*\\\":return GROWABLE_HEAP_U32()[ptr>>>2>>>0];default:abort(`invalid type for getValue: ${type}`)}}Module[\\\"getValue\\\"]=getValue;var wasmTableMirror=[];Module[\\\"wasmTableMirror\\\"]=wasmTableMirror;var wasmTable;Module[\\\"wasmTable\\\"]=wasmTable;var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func};Module[\\\"getWasmTableEntry\\\"]=getWasmTableEntry;var invokeEntryPoint=(ptr,arg)=>{var result=getWasmTableEntry(ptr)(arg);function finish(result){if(keepRuntimeAlive()){PThread.setExitStatus(result)}else{__emscripten_thread_exit(result)}}finish(result)};Module[\\\"invokeEntryPoint\\\"]=invokeEntryPoint;var noExitRuntime=Module[\\\"noExitRuntime\\\"]||true;Module[\\\"noExitRuntime\\\"]=noExitRuntime;var registerTLSInit=tlsInitFunc=>PThread.tlsInitFunctions.push(tlsInitFunc);Module[\\\"registerTLSInit\\\"]=registerTLSInit;function setValue(ptr,value,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":GROWABLE_HEAP_I8()[ptr>>>0]=value;break;case\\\"i8\\\":GROWABLE_HEAP_I8()[ptr>>>0]=value;break;case\\\"i16\\\":GROWABLE_HEAP_I16()[ptr>>>1>>>0]=value;break;case\\\"i32\\\":GROWABLE_HEAP_I32()[ptr>>>2>>>0]=value;break;case\\\"i64\\\":abort(\\\"to do setValue(i64) use WASM_BIGINT\\\");case\\\"float\\\":GROWABLE_HEAP_F32()[ptr>>>2>>>0]=value;break;case\\\"double\\\":GROWABLE_HEAP_F64()[ptr>>>3>>>0]=value;break;case\\\"*\\\":GROWABLE_HEAP_U32()[ptr>>>2>>>0]=value;break;default:abort(`invalid type for setValue: ${type}`)}}Module[\\\"setValue\\\"]=setValue;function ___emscripten_init_main_thread_js(tb){tb>>>=0;__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1,!ENVIRONMENT_IS_WEB,65536,false);PThread.threadInitTLS()}Module[\\\"___emscripten_init_main_thread_js\\\"]=___emscripten_init_main_thread_js;function ___emscripten_thread_cleanup(thread){thread>>>=0;if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({\\\"cmd\\\":\\\"cleanupThread\\\",\\\"thread\\\":thread})}Module[\\\"___emscripten_thread_cleanup\\\"]=___emscripten_thread_cleanup;function pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(2,0,1,pthread_ptr,attr,startRoutine,arg);return ___pthread_create_js(pthread_ptr,attr,startRoutine,arg)}Module[\\\"pthreadCreateProxied\\\"]=pthreadCreateProxied;function ___pthread_create_js(pthread_ptr,attr,startRoutine,arg){pthread_ptr>>>=0;attr>>>=0;startRoutine>>>=0;arg>>>=0;if(typeof SharedArrayBuffer==\\\"undefined\\\"){err(\\\"Current environment does not support SharedArrayBuffer, pthreads are not available!\\\");return 6}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg)}if(error)return error;var threadParams={startRoutine:startRoutine,pthread_ptr:pthread_ptr,arg:arg,transferList:transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd=\\\"spawnThread\\\";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}Module[\\\"___pthread_create_js\\\"]=___pthread_create_js;var PATH={isAbs:path=>path.charAt(0)===\\\"/\\\",splitPath:filename=>{var splitPathRe=/^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\\\".\\\"){parts.splice(i,1)}else if(last===\\\"..\\\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\\\"..\\\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)===\\\"/\\\";path=PATH.normalizeArray(path.split(\\\"/\\\").filter(p=>!!p),!isAbsolute).join(\\\"/\\\");if(!path&&!isAbsolute){path=\\\".\\\"}if(path&&trailingSlash){path+=\\\"/\\\"}return(isAbsolute?\\\"/\\\":\\\"\\\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\\\".\\\"}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:path=>{if(path===\\\"/\\\")return\\\"/\\\";path=PATH.normalize(path);path=path.replace(/\\\\/$/,\\\"\\\");var lastSlash=path.lastIndexOf(\\\"/\\\");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:(...paths)=>PATH.normalize(paths.join(\\\"/\\\")),join2:(l,r)=>PATH.normalize(l+\\\"/\\\"+r)};Module[\\\"PATH\\\"]=PATH;var initRandomFill=()=>{if(typeof crypto==\\\"object\\\"&&typeof crypto[\\\"getRandomValues\\\"]==\\\"function\\\"){return view=>(view.set(crypto.getRandomValues(new Uint8Array(view.byteLength))),view)}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=require(\\\"crypto\\\");var randomFillSync=crypto_module[\\\"randomFillSync\\\"];if(randomFillSync){return view=>crypto_module[\\\"randomFillSync\\\"](view)}var randomBytes=crypto_module[\\\"randomBytes\\\"];return view=>(view.set(randomBytes(view.byteLength)),view)}catch(e){}}abort(\\\"initRandomDevice\\\")};Module[\\\"initRandomFill\\\"]=initRandomFill;var randomFill=view=>(randomFill=initRandomFill())(view);Module[\\\"randomFill\\\"]=randomFill;var PATH_FS={resolve:(...args)=>{var resolvedPath=\\\"\\\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\\\"string\\\"){throw new TypeError(\\\"Arguments to path.resolve must be strings\\\")}else if(!path){return\\\"\\\"}resolvedPath=path+\\\"/\\\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\\\"/\\\").filter(p=>!!p),!resolvedAbsolute).join(\\\"/\\\");return(resolvedAbsolute?\\\"/\\\":\\\"\\\")+resolvedPath||\\\".\\\"},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\\\"\\\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\\\"\\\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\\\"/\\\"));var toParts=trim(to.split(\\\"/\\\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\\\"..\\\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\\\"/\\\")}};Module[\\\"PATH_FS\\\"]=PATH_FS;var UTF8Decoder=typeof TextDecoder!=\\\"undefined\\\"?new TextDecoder(\\\"utf8\\\"):undefined;Module[\\\"UTF8Decoder\\\"]=UTF8Decoder;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer?heapOrArray.slice(idx,endPtr):heapOrArray.subarray(idx,endPtr))}var str=\\\"\\\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};Module[\\\"UTF8ArrayToString\\\"]=UTF8ArrayToString;var FS_stdin_getChar_buffer=[];Module[\\\"FS_stdin_getChar_buffer\\\"]=FS_stdin_getChar_buffer;var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};Module[\\\"lengthBytesUTF8\\\"]=lengthBytesUTF8;var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{outIdx>>>=0;if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}}heap[outIdx>>>0]=0;return outIdx-startIdx};Module[\\\"stringToUTF8Array\\\"]=stringToUTF8Array;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}Module[\\\"intArrayFromString\\\"]=intArrayFromString;var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;var fd=process.stdin.fd;try{bytesRead=fs.readSync(fd,buf)}catch(e){if(e.toString().includes(\\\"EOF\\\"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString(\\\"utf-8\\\")}else{result=null}}else if(typeof window!=\\\"undefined\\\"&&typeof window.prompt==\\\"function\\\"){result=window.prompt(\\\"Input: \\\");if(result!==null){result+=\\\"\\\\n\\\"}}else if(typeof readline==\\\"function\\\"){result=readline();if(result!==null){result+=\\\"\\\\n\\\"}}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};Module[\\\"FS_stdin_getChar\\\"]=FS_stdin_getChar;var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};Module[\\\"TTY\\\"]=TTY;var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;Module[\\\"alignMemory\\\"]=alignMemory;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;return zeroMemory(ptr,size)};Module[\\\"mmapAlloc\\\"]=mmapAlloc;var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\\\"/\\\",16384|511,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){throw FS.genericErrors[44]},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir},unlink(parent,name){delete parent.contents[name];parent.timestamp=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now()},readdir(node){var entries=[\\\".\\\",\\\"..\\\"];for(var key of Object.keys(node.contents)){entries.push(key)}return entries},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===GROWABLE_HEAP_I8().buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===GROWABLE_HEAP_I8().buffer){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}GROWABLE_HEAP_I8().set(contents,ptr>>>0)}return{ptr:ptr,allocated:allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};Module[\\\"MEMFS\\\"]=MEMFS;var asyncLoad=(url,onload,onerror,noRunDep)=>{var dep=!noRunDep?getUniqueRunDependency(`al ${url}`):\\\"\\\";readAsync(url,arrayBuffer=>{onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep)},event=>{if(onerror){onerror()}else{throw`Loading data file \\\"${url}\\\" failed.`}});if(dep)addRunDependency(dep)};Module[\\\"asyncLoad\\\"]=asyncLoad;var FS_createDataFile=(parent,name,fileData,canRead,canWrite,canOwn)=>{FS.createDataFile(parent,name,fileData,canRead,canWrite,canOwn)};Module[\\\"FS_createDataFile\\\"]=FS_createDataFile;var preloadPlugins=Module[\\\"preloadPlugins\\\"]||[];Module[\\\"preloadPlugins\\\"]=preloadPlugins;var FS_handledByPreloadPlugin=(byteArray,fullname,finish,onerror)=>{if(typeof Browser!=\\\"undefined\\\")Browser.init();var handled=false;preloadPlugins.forEach(plugin=>{if(handled)return;if(plugin[\\\"canHandle\\\"](fullname)){plugin[\\\"handle\\\"](byteArray,fullname,finish,onerror);handled=true}});return handled};Module[\\\"FS_handledByPreloadPlugin\\\"]=FS_handledByPreloadPlugin;var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);function processData(byteArray){function finish(byteArray){preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}onload?.();removeRunDependency(dep)}if(FS_handledByPreloadPlugin(byteArray,fullname,finish,()=>{onerror?.();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url==\\\"string\\\"){asyncLoad(url,processData,onerror)}else{processData(url)}};Module[\\\"FS_createPreloadedFile\\\"]=FS_createPreloadedFile;var FS_modeStringToFlags=str=>{var flagModes={\\\"r\\\":0,\\\"r+\\\":2,\\\"w\\\":512|64|1,\\\"w+\\\":512|64|2,\\\"a\\\":1024|64|1,\\\"a+\\\":1024|64|2};var flags=flagModes[str];if(typeof flags==\\\"undefined\\\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};Module[\\\"FS_modeStringToFlags\\\"]=FS_modeStringToFlags;var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};Module[\\\"FS_getMode\\\"]=FS_getMode;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\\\"/\\\",initialized:false,ignorePermissions:true,ErrnoError:class{constructor(errno){this.name=\\\"ErrnoError\\\";this.errno=errno}},genericErrors:{},filesystems:null,syncFSRequests:0,FSStream:class{constructor(){this.shared={}}get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;this.readMode=292|73;this.writeMode=146}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){path=PATH_FS.resolve(path);if(!path)return{path:\\\"\\\",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=path.split(\\\"/\\\").filter(p=>!!p);var current=FS.root;var current_path=\\\"/\\\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return{path:current_path,node:current}},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\\\"/\\\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\\\"r\\\",\\\"w\\\",\\\"rw\\\"][flag&3];if(flag&512){perms+=\\\"w\\\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\\\"r\\\")&&!(node.mode&292)){return 2}else if(perms.includes(\\\"w\\\")&&!(node.mode&146)){return 2}else if(perms.includes(\\\"x\\\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\\\"x\\\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\\\"wx\\\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\\\"wx\\\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!==\\\"r\\\"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\\\"function\\\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount(type,opts,mountpoint){var root=mountpoint===\\\"/\\\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name===\\\".\\\"||name===\\\"..\\\"){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\\\"/\\\");var d=\\\"\\\";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+=\\\"/\\\"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\\\"undefined\\\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat(path){return FS.stat(path,true)},chmod(path,mode,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.chmod(stream.node,mode)},chown(path,uid,gid,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.chown(stream.node,uid,gid)},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open(path,flags,mode){if(path===\\\"\\\"){throw new FS.ErrnoError(44)}flags=typeof flags==\\\"string\\\"?FS_modeStringToFlags(flags):flags;mode=typeof mode==\\\"undefined\\\"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==\\\"object\\\"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module[\\\"logReadFiles\\\"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\\\"binary\\\";if(opts.encoding!==\\\"utf8\\\"&&opts.encoding!==\\\"binary\\\"){throw new Error(`Invalid encoding type \\\"${opts.encoding}\\\"`)}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\\\"utf8\\\"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding===\\\"binary\\\"){ret=buf}FS.close(stream);return ret},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\\\"string\\\"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error(\\\"Unsupported data type\\\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\\\"x\\\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\\\"/tmp\\\");FS.mkdir(\\\"/home\\\");FS.mkdir(\\\"/home/web_user\\\")},createDefaultDevices(){FS.mkdir(\\\"/dev\\\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev(\\\"/dev/null\\\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\\\"/dev/tty\\\",FS.makedev(5,0));FS.mkdev(\\\"/dev/tty1\\\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomLeft=randomFill(randomBuffer).byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\\\"/dev\\\",\\\"random\\\",randomByte);FS.createDevice(\\\"/dev\\\",\\\"urandom\\\",randomByte);FS.mkdir(\\\"/dev/shm\\\");FS.mkdir(\\\"/dev/shm/tmp\\\")},createSpecialDirectories(){FS.mkdir(\\\"/proc\\\");var proc_self=FS.mkdir(\\\"/proc/self\\\");FS.mkdir(\\\"/proc/self/fd\\\");FS.mount({mount(){var node=FS.createNode(proc_self,\\\"fd\\\",16384|511,73);node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\\\"fake\\\"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},\\\"/proc/self/fd\\\")},createStandardStreams(){if(Module[\\\"stdin\\\"]){FS.createDevice(\\\"/dev\\\",\\\"stdin\\\",Module[\\\"stdin\\\"])}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdin\\\")}if(Module[\\\"stdout\\\"]){FS.createDevice(\\\"/dev\\\",\\\"stdout\\\",null,Module[\\\"stdout\\\"])}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdout\\\")}if(Module[\\\"stderr\\\"]){FS.createDevice(\\\"/dev\\\",\\\"stderr\\\",null,Module[\\\"stderr\\\"])}else{FS.symlink(\\\"/dev/tty1\\\",\\\"/dev/stderr\\\")}var stdin=FS.open(\\\"/dev/stdin\\\",0);var stdout=FS.open(\\\"/dev/stdout\\\",1);var stderr=FS.open(\\\"/dev/stderr\\\",1)},staticInit(){[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack=\\\"<generic error, no stack>\\\"});FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\\\"/\\\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={\\\"MEMFS\\\":MEMFS}},init(input,output,error){FS.init.initialized=true;Module[\\\"stdin\\\"]=input||Module[\\\"stdin\\\"];Module[\\\"stdout\\\"]=output||Module[\\\"stdout\\\"];Module[\\\"stderr\\\"]=error||Module[\\\"stderr\\\"];FS.createStandardStreams()},quit(){FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\\\"/\\\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);var parts=path.split(\\\"/\\\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\\\"string\\\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!=\\\"undefined\\\"){throw new Error(\\\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\\\")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}else{throw new Error(\\\"Cannot load without read() or XMLHttpRequest.\\\")}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{constructor(){this.lengthKnown=false;this.chunks=[]}get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\\\"HEAD\\\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);var datalength=Number(xhr.getResponseHeader(\\\"Content-length\\\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\\\"Accept-Ranges\\\"))&&header===\\\"bytes\\\";var usesGzip=(header=xhr.getResponseHeader(\\\"Content-Encoding\\\"))&&header===\\\"gzip\\\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error(\\\"invalid range (\\\"+from+\\\", \\\"+to+\\\") or no bytes requested!\\\");if(to>datalength-1)throw new Error(\\\"only \\\"+datalength+\\\" bytes available! programmer error!\\\");var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\\\"Range\\\",\\\"bytes=\\\"+from+\\\"-\\\"+to);xhr.responseType=\\\"arraybuffer\\\";if(xhr.overrideMimeType){xhr.overrideMimeType(\\\"text/plain; charset=x-user-defined\\\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\\\"\\\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\")throw new Error(\\\"doXHR failed!\\\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\\\"LazyFiles on gzip forces download of the whole file when length is accessed\\\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(typeof XMLHttpRequest!=\\\"undefined\\\"){if(!ENVIRONMENT_IS_WORKER)throw\\\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\\\";var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,GROWABLE_HEAP_I8(),ptr,length,position);return{ptr:ptr,allocated:true}};node.stream_ops=stream_ops;return node}};Module[\\\"FS\\\"]=FS;var UTF8ToString=(ptr,maxBytesToRead)=>{ptr>>>=0;return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):\\\"\\\"};Module[\\\"UTF8ToString\\\"]=UTF8ToString;var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat(func,path,buf){var stat=func(path);GROWABLE_HEAP_I32()[buf>>>2>>>0]=stat.dev;GROWABLE_HEAP_I32()[buf+4>>>2>>>0]=stat.mode;GROWABLE_HEAP_U32()[buf+8>>>2>>>0]=stat.nlink;GROWABLE_HEAP_I32()[buf+12>>>2>>>0]=stat.uid;GROWABLE_HEAP_I32()[buf+16>>>2>>>0]=stat.gid;GROWABLE_HEAP_I32()[buf+20>>>2>>>0]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+24>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+28>>>2>>>0]=tempI64[1];GROWABLE_HEAP_I32()[buf+32>>>2>>>0]=4096;GROWABLE_HEAP_I32()[buf+36>>>2>>>0]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+40>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+44>>>2>>>0]=tempI64[1];GROWABLE_HEAP_U32()[buf+48>>>2>>>0]=atime%1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+56>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+60>>>2>>>0]=tempI64[1];GROWABLE_HEAP_U32()[buf+64>>>2>>>0]=mtime%1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+72>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+76>>>2>>>0]=tempI64[1];GROWABLE_HEAP_U32()[buf+80>>>2>>>0]=ctime%1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[buf+88>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[buf+92>>>2>>>0]=tempI64[1];return 0},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=GROWABLE_HEAP_U8().slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},varargs:undefined,get(){var ret=GROWABLE_HEAP_I32()[+SYSCALLS.varargs>>>2>>>0];SYSCALLS.varargs+=4;return ret},getp(){return SYSCALLS.get()},getStr(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream}};Module[\\\"SYSCALLS\\\"]=SYSCALLS;function ___syscall_fcntl64(fd,cmd,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(3,0,1,fd,cmd,varargs);varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 12:{var arg=SYSCALLS.getp();var offset=0;GROWABLE_HEAP_I16()[arg+offset>>>1>>>0]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_fcntl64\\\"]=___syscall_fcntl64;function ___syscall_ioctl(fd,op,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(4,0,1,fd,op,varargs);varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:{if(!stream.tty)return-59;return 0}case 21505:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcgets){var termios=stream.tty.ops.ioctl_tcgets(stream);var argp=SYSCALLS.getp();GROWABLE_HEAP_I32()[argp>>>2>>>0]=termios.c_iflag||0;GROWABLE_HEAP_I32()[argp+4>>>2>>>0]=termios.c_oflag||0;GROWABLE_HEAP_I32()[argp+8>>>2>>>0]=termios.c_cflag||0;GROWABLE_HEAP_I32()[argp+12>>>2>>>0]=termios.c_lflag||0;for(var i=0;i<32;i++){GROWABLE_HEAP_I8()[argp+i+17>>>0]=termios.c_cc[i]||0}return 0}return 0}case 21510:case 21511:case 21512:{if(!stream.tty)return-59;return 0}case 21506:case 21507:case 21508:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcsets){var argp=SYSCALLS.getp();var c_iflag=GROWABLE_HEAP_I32()[argp>>>2>>>0];var c_oflag=GROWABLE_HEAP_I32()[argp+4>>>2>>>0];var c_cflag=GROWABLE_HEAP_I32()[argp+8>>>2>>>0];var c_lflag=GROWABLE_HEAP_I32()[argp+12>>>2>>>0];var c_cc=[];for(var i=0;i<32;i++){c_cc.push(GROWABLE_HEAP_I8()[argp+i+17>>>0])}return stream.tty.ops.ioctl_tcsets(stream.tty,op,{c_iflag:c_iflag,c_oflag:c_oflag,c_cflag:c_cflag,c_lflag:c_lflag,c_cc:c_cc})}return 0}case 21519:{if(!stream.tty)return-59;var argp=SYSCALLS.getp();GROWABLE_HEAP_I32()[argp>>>2>>>0]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=SYSCALLS.getp();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tiocgwinsz){var winsize=stream.tty.ops.ioctl_tiocgwinsz(stream.tty);var argp=SYSCALLS.getp();GROWABLE_HEAP_I16()[argp>>>1>>>0]=winsize[0];GROWABLE_HEAP_I16()[argp+2>>>1>>>0]=winsize[1]}return 0}case 21524:{if(!stream.tty)return-59;return 0}case 21515:{if(!stream.tty)return-59;return 0}default:return-28}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_ioctl\\\"]=___syscall_ioctl;function ___syscall_openat(dirfd,path,flags,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(5,0,1,dirfd,path,flags,varargs);path>>>=0;varargs>>>=0;SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_openat\\\"]=___syscall_openat;var nowIsMonotonic=1;Module[\\\"nowIsMonotonic\\\"]=nowIsMonotonic;var __emscripten_get_now_is_monotonic=()=>nowIsMonotonic;Module[\\\"__emscripten_get_now_is_monotonic\\\"]=__emscripten_get_now_is_monotonic;var maybeExit=()=>{if(!keepRuntimeAlive()){try{if(ENVIRONMENT_IS_PTHREAD)__emscripten_thread_exit(EXITSTATUS);else _exit(EXITSTATUS)}catch(e){handleException(e)}}};Module[\\\"maybeExit\\\"]=maybeExit;var callUserCallback=func=>{if(ABORT){return}try{func();maybeExit()}catch(e){handleException(e)}};Module[\\\"callUserCallback\\\"]=callUserCallback;function __emscripten_thread_mailbox_await(pthread_ptr){pthread_ptr>>>=0;if(typeof Atomics.waitAsync===\\\"function\\\"){var wait=Atomics.waitAsync(GROWABLE_HEAP_I32(),pthread_ptr>>>2,pthread_ptr);wait.value.then(checkMailbox);var waitingAsync=pthread_ptr+128;Atomics.store(GROWABLE_HEAP_I32(),waitingAsync>>>2,1)}}Module[\\\"__emscripten_thread_mailbox_await\\\"]=__emscripten_thread_mailbox_await;var checkMailbox=()=>{var pthread_ptr=_pthread_self();if(pthread_ptr){__emscripten_thread_mailbox_await(pthread_ptr);callUserCallback(__emscripten_check_mailbox)}};Module[\\\"checkMailbox\\\"]=checkMailbox;function __emscripten_notify_mailbox_postmessage(targetThreadId,currThreadId,mainThreadId){targetThreadId>>>=0;currThreadId>>>=0;mainThreadId>>>=0;if(targetThreadId==currThreadId){setTimeout(checkMailbox)}else if(ENVIRONMENT_IS_PTHREAD){postMessage({\\\"targetThread\\\":targetThreadId,\\\"cmd\\\":\\\"checkMailbox\\\"})}else{var worker=PThread.pthreads[targetThreadId];if(!worker){return}worker.postMessage({\\\"cmd\\\":\\\"checkMailbox\\\"})}}Module[\\\"__emscripten_notify_mailbox_postmessage\\\"]=__emscripten_notify_mailbox_postmessage;var proxiedJSCallArgs=[];Module[\\\"proxiedJSCallArgs\\\"]=proxiedJSCallArgs;function __emscripten_receive_on_main_thread_js(funcIndex,emAsmAddr,callingThread,numCallArgs,args){emAsmAddr>>>=0;callingThread>>>=0;args>>>=0;proxiedJSCallArgs.length=numCallArgs;var b=args>>>3;for(var i=0;i<numCallArgs;i++){proxiedJSCallArgs[i]=GROWABLE_HEAP_F64()[b+i>>>0]}var func=proxiedFunctionTable[funcIndex];PThread.currentProxiedOperationCallerThread=callingThread;var rtn=func(...proxiedJSCallArgs);PThread.currentProxiedOperationCallerThread=0;return rtn}Module[\\\"__emscripten_receive_on_main_thread_js\\\"]=__emscripten_receive_on_main_thread_js;function __emscripten_thread_set_strongref(thread){thread>>>=0;if(ENVIRONMENT_IS_NODE){PThread.pthreads[thread].ref()}}Module[\\\"__emscripten_thread_set_strongref\\\"]=__emscripten_thread_set_strongref;function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(6,0,1,len,prot,flags,fd,offset_low,offset_high,allocated,addr);len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);allocated>>>=0;addr>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;GROWABLE_HEAP_I32()[allocated>>>2>>>0]=res.allocated;GROWABLE_HEAP_U32()[addr>>>2>>>0]=ptr;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__mmap_js\\\"]=__mmap_js;function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(7,0,1,addr,len,prot,flags,fd,offset_low,offset_high);addr>>>=0;len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__munmap_js\\\"]=__munmap_js;var _abort=()=>{abort(\\\"\\\")};Module[\\\"_abort\\\"]=_abort;var warnOnce=text=>{warnOnce.shown||={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;if(ENVIRONMENT_IS_NODE)text=\\\"warning: \\\"+text;err(text)}};Module[\\\"warnOnce\\\"]=warnOnce;var _emscripten_check_blocking_allowed=()=>{};Module[\\\"_emscripten_check_blocking_allowed\\\"]=_emscripten_check_blocking_allowed;var _emscripten_date_now=()=>Date.now();Module[\\\"_emscripten_date_now\\\"]=_emscripten_date_now;var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};Module[\\\"runtimeKeepalivePush\\\"]=runtimeKeepalivePush;var _emscripten_exit_with_live_runtime=()=>{runtimeKeepalivePush();throw\\\"unwind\\\"};Module[\\\"_emscripten_exit_with_live_runtime\\\"]=_emscripten_exit_with_live_runtime;var _emscripten_get_now;_emscripten_get_now=()=>performance.timeOrigin+performance.now();Module[\\\"_emscripten_get_now\\\"]=_emscripten_get_now;var getHeapMax=()=>4294901760;Module[\\\"getHeapMax\\\"]=getHeapMax;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};Module[\\\"growMemory\\\"]=growMemory;function _emscripten_resize_heap(requestedSize){requestedSize>>>=0;var oldSize=GROWABLE_HEAP_U8().length;if(requestedSize<=oldSize){return false}var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false}Module[\\\"_emscripten_resize_heap\\\"]=_emscripten_resize_heap;var ENV={};Module[\\\"ENV\\\"]=ENV;var getExecutableName=()=>thisProgram||\\\"./this.program\\\";Module[\\\"getExecutableName\\\"]=getExecutableName;var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(typeof navigator==\\\"object\\\"&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\";var env={\\\"USER\\\":\\\"web_user\\\",\\\"LOGNAME\\\":\\\"web_user\\\",\\\"PATH\\\":\\\"/\\\",\\\"PWD\\\":\\\"/\\\",\\\"HOME\\\":\\\"/home/web_user\\\",\\\"LANG\\\":lang,\\\"_\\\":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};Module[\\\"getEnvStrings\\\"]=getEnvStrings;var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){GROWABLE_HEAP_I8()[buffer++>>>0]=str.charCodeAt(i)}GROWABLE_HEAP_I8()[buffer>>>0]=0};Module[\\\"stringToAscii\\\"]=stringToAscii;var _environ_get=function(__environ,environ_buf){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(8,0,1,__environ,environ_buf);__environ>>>=0;environ_buf>>>=0;var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;GROWABLE_HEAP_U32()[__environ+i*4>>>2>>>0]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1});return 0};Module[\\\"_environ_get\\\"]=_environ_get;var _environ_sizes_get=function(penviron_count,penviron_buf_size){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(9,0,1,penviron_count,penviron_buf_size);penviron_count>>>=0;penviron_buf_size>>>=0;var strings=getEnvStrings();GROWABLE_HEAP_U32()[penviron_count>>>2>>>0]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);GROWABLE_HEAP_U32()[penviron_buf_size>>>2>>>0]=bufSize;return 0};Module[\\\"_environ_sizes_get\\\"]=_environ_sizes_get;function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(10,0,1,fd);try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_close\\\"]=_fd_close;var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2>>>0];var len=GROWABLE_HEAP_U32()[iov+4>>>2>>>0];iov+=8;var curr=FS.read(stream,GROWABLE_HEAP_I8(),ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!==\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doReadv\\\"]=doReadv;function _fd_read(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(11,0,1,fd,iov,iovcnt,pnum);iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);GROWABLE_HEAP_U32()[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_read\\\"]=_fd_read;function _fd_seek(fd,offset_low,offset_high,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(12,0,1,fd,offset_low,offset_high,whence,newOffset);var offset=convertI32PairToI53Checked(offset_low,offset_high);newOffset>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],GROWABLE_HEAP_I32()[newOffset>>>2>>>0]=tempI64[0],GROWABLE_HEAP_I32()[newOffset+4>>>2>>>0]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_seek\\\"]=_fd_seek;var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2>>>0];var len=GROWABLE_HEAP_U32()[iov+4>>>2>>>0];iov+=8;var curr=FS.write(stream,GROWABLE_HEAP_I8(),ptr,len,offset);if(curr<0)return-1;ret+=curr;if(typeof offset!==\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doWritev\\\"]=doWritev;function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(13,0,1,fd,iov,iovcnt,pnum);iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);GROWABLE_HEAP_U32()[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_write\\\"]=_fd_write;function _getentropy(buffer,size){buffer>>>=0;size>>>=0;randomFill(GROWABLE_HEAP_U8().subarray(buffer>>>0,buffer+size>>>0));return 0}Module[\\\"_getentropy\\\"]=_getentropy;var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);Module[\\\"isLeapYear\\\"]=isLeapYear;var arraySum=(array,index)=>{var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum};Module[\\\"arraySum\\\"]=arraySum;var MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];Module[\\\"MONTH_DAYS_LEAP\\\"]=MONTH_DAYS_LEAP;var MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];Module[\\\"MONTH_DAYS_REGULAR\\\"]=MONTH_DAYS_REGULAR;var addDays=(date,days)=>{var newDate=new Date(date.getTime());while(days>0){var leap=isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate};Module[\\\"addDays\\\"]=addDays;var writeArrayToMemory=(array,buffer)=>{GROWABLE_HEAP_I8().set(array,buffer>>>0)};Module[\\\"writeArrayToMemory\\\"]=writeArrayToMemory;function _strftime(s,maxsize,format,tm){s>>>=0;maxsize>>>=0;format>>>=0;tm>>>=0;var tm_zone=GROWABLE_HEAP_U32()[tm+40>>>2>>>0];var date={tm_sec:GROWABLE_HEAP_I32()[tm>>>2>>>0],tm_min:GROWABLE_HEAP_I32()[tm+4>>>2>>>0],tm_hour:GROWABLE_HEAP_I32()[tm+8>>>2>>>0],tm_mday:GROWABLE_HEAP_I32()[tm+12>>>2>>>0],tm_mon:GROWABLE_HEAP_I32()[tm+16>>>2>>>0],tm_year:GROWABLE_HEAP_I32()[tm+20>>>2>>>0],tm_wday:GROWABLE_HEAP_I32()[tm+24>>>2>>>0],tm_yday:GROWABLE_HEAP_I32()[tm+28>>>2>>>0],tm_isdst:GROWABLE_HEAP_I32()[tm+32>>>2>>>0],tm_gmtoff:GROWABLE_HEAP_I32()[tm+36>>>2>>>0],tm_zone:tm_zone?UTF8ToString(tm_zone):\\\"\\\"};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={\\\"%c\\\":\\\"%a %b %d %H:%M:%S %Y\\\",\\\"%D\\\":\\\"%m/%d/%y\\\",\\\"%F\\\":\\\"%Y-%m-%d\\\",\\\"%h\\\":\\\"%b\\\",\\\"%r\\\":\\\"%I:%M:%S %p\\\",\\\"%R\\\":\\\"%H:%M\\\",\\\"%T\\\":\\\"%H:%M:%S\\\",\\\"%x\\\":\\\"%m/%d/%y\\\",\\\"%X\\\":\\\"%H:%M:%S\\\",\\\"%Ec\\\":\\\"%c\\\",\\\"%EC\\\":\\\"%C\\\",\\\"%Ex\\\":\\\"%m/%d/%y\\\",\\\"%EX\\\":\\\"%H:%M:%S\\\",\\\"%Ey\\\":\\\"%y\\\",\\\"%EY\\\":\\\"%Y\\\",\\\"%Od\\\":\\\"%d\\\",\\\"%Oe\\\":\\\"%e\\\",\\\"%OH\\\":\\\"%H\\\",\\\"%OI\\\":\\\"%I\\\",\\\"%Om\\\":\\\"%m\\\",\\\"%OM\\\":\\\"%M\\\",\\\"%OS\\\":\\\"%S\\\",\\\"%Ou\\\":\\\"%u\\\",\\\"%OU\\\":\\\"%U\\\",\\\"%OV\\\":\\\"%V\\\",\\\"%Ow\\\":\\\"%w\\\",\\\"%OW\\\":\\\"%W\\\",\\\"%Oy\\\":\\\"%y\\\"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,\\\"g\\\"),EXPANSION_RULES_1[rule])}var WEEKDAYS=[\\\"Sunday\\\",\\\"Monday\\\",\\\"Tuesday\\\",\\\"Wednesday\\\",\\\"Thursday\\\",\\\"Friday\\\",\\\"Saturday\\\"];var MONTHS=[\\\"January\\\",\\\"February\\\",\\\"March\\\",\\\"April\\\",\\\"May\\\",\\\"June\\\",\\\"July\\\",\\\"August\\\",\\\"September\\\",\\\"October\\\",\\\"November\\\",\\\"December\\\"];function leadingSomething(value,digits,character){var str=typeof value==\\\"number\\\"?value.toString():value||\\\"\\\";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,\\\"0\\\")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}return thisDate.getFullYear()}return thisDate.getFullYear()-1}var EXPANSION_RULES_2={\\\"%a\\\":date=>WEEKDAYS[date.tm_wday].substring(0,3),\\\"%A\\\":date=>WEEKDAYS[date.tm_wday],\\\"%b\\\":date=>MONTHS[date.tm_mon].substring(0,3),\\\"%B\\\":date=>MONTHS[date.tm_mon],\\\"%C\\\":date=>{var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},\\\"%d\\\":date=>leadingNulls(date.tm_mday,2),\\\"%e\\\":date=>leadingSomething(date.tm_mday,2,\\\" \\\"),\\\"%g\\\":date=>getWeekBasedYear(date).toString().substring(2),\\\"%G\\\":getWeekBasedYear,\\\"%H\\\":date=>leadingNulls(date.tm_hour,2),\\\"%I\\\":date=>{var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},\\\"%j\\\":date=>leadingNulls(date.tm_mday+arraySum(isLeapYear(date.tm_year+1900)?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,date.tm_mon-1),3),\\\"%m\\\":date=>leadingNulls(date.tm_mon+1,2),\\\"%M\\\":date=>leadingNulls(date.tm_min,2),\\\"%n\\\":()=>\\\"\\\\n\\\",\\\"%p\\\":date=>{if(date.tm_hour>=0&&date.tm_hour<12){return\\\"AM\\\"}return\\\"PM\\\"},\\\"%S\\\":date=>leadingNulls(date.tm_sec,2),\\\"%t\\\":()=>\\\"\\\\t\\\",\\\"%u\\\":date=>date.tm_wday||7,\\\"%U\\\":date=>{var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},\\\"%V\\\":date=>{var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},\\\"%w\\\":date=>date.tm_wday,\\\"%W\\\":date=>{var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},\\\"%y\\\":date=>(date.tm_year+1900).toString().substring(2),\\\"%Y\\\":date=>date.tm_year+1900,\\\"%z\\\":date=>{var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?\\\"+\\\":\\\"-\\\")+String(\\\"0000\\\"+off).slice(-4)},\\\"%Z\\\":date=>date.tm_zone,\\\"%%\\\":()=>\\\"%\\\"};pattern=pattern.replace(/%%/g,\\\"\\\\0\\\\0\\\");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,\\\"g\\\"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\\\\0\\\\0/g,\\\"%\\\");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}Module[\\\"_strftime\\\"]=_strftime;function _strftime_l(s,maxsize,format,tm,loc){s>>>=0;maxsize>>>=0;format>>>=0;tm>>>=0;loc>>>=0;return _strftime(s,maxsize,format,tm)}Module[\\\"_strftime_l\\\"]=_strftime_l;var getCFunc=ident=>{var func=Module[\\\"_\\\"+ident];return func};Module[\\\"getCFunc\\\"]=getCFunc;var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite);Module[\\\"stringToUTF8\\\"]=stringToUTF8;var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};Module[\\\"stringToUTF8OnStack\\\"]=stringToUTF8OnStack;var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={\\\"string\\\":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},\\\"array\\\":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\\\"string\\\"){return UTF8ToString(ret)}if(returnType===\\\"boolean\\\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func(...cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};Module[\\\"ccall\\\"]=ccall;var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\\\"number\\\"||type===\\\"boolean\\\");var numericRet=returnType!==\\\"string\\\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};Module[\\\"cwrap\\\"]=cwrap;var FS_unlink=path=>FS.unlink(path);Module[\\\"FS_unlink\\\"]=FS_unlink;PThread.init();FS.createPreloadedFile=FS_createPreloadedFile;FS.staticInit();Module[\\\"FS_createPath\\\"]=FS.createPath;Module[\\\"FS_createDataFile\\\"]=FS.createDataFile;Module[\\\"FS_createPreloadedFile\\\"]=FS.createPreloadedFile;Module[\\\"FS_unlink\\\"]=FS.unlink;Module[\\\"FS_createLazyFile\\\"]=FS.createLazyFile;Module[\\\"FS_createDevice\\\"]=FS.createDevice;var proxiedFunctionTable=[_proc_exit,exitOnMainThread,pthreadCreateProxied,___syscall_fcntl64,___syscall_ioctl,___syscall_openat,__mmap_js,__munmap_js,_environ_get,_environ_sizes_get,_fd_close,_fd_read,_fd_seek,_fd_write];var wasmImports={z:___emscripten_init_main_thread_js,e:___emscripten_thread_cleanup,w:___pthread_create_js,d:___syscall_fcntl64,j:___syscall_ioctl,k:___syscall_openat,u:__emscripten_get_now_is_monotonic,t:__emscripten_notify_mailbox_postmessage,x:__emscripten_receive_on_main_thread_js,y:__emscripten_thread_mailbox_await,m:__emscripten_thread_set_strongref,n:__mmap_js,o:__munmap_js,b:_abort,f:_emscripten_check_blocking_allowed,h:_emscripten_date_now,l:_emscripten_exit_with_live_runtime,c:_emscripten_get_now,s:_emscripten_resize_heap,A:_environ_get,B:_environ_sizes_get,v:_exit,g:_fd_close,i:_fd_read,p:_fd_seek,C:_fd_write,q:_getentropy,a:wasmMemory,r:_strftime_l};var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports[\\\"D\\\"])();var _wllama_malloc=Module[\\\"_wllama_malloc\\\"]=(a0,a1)=>(_wllama_malloc=Module[\\\"_wllama_malloc\\\"]=wasmExports[\\\"E\\\"])(a0,a1);var _wllama_start=Module[\\\"_wllama_start\\\"]=()=>(_wllama_start=Module[\\\"_wllama_start\\\"]=wasmExports[\\\"F\\\"])();var _wllama_action=Module[\\\"_wllama_action\\\"]=(a0,a1)=>(_wllama_action=Module[\\\"_wllama_action\\\"]=wasmExports[\\\"G\\\"])(a0,a1);var _wllama_exit=Module[\\\"_wllama_exit\\\"]=()=>(_wllama_exit=Module[\\\"_wllama_exit\\\"]=wasmExports[\\\"H\\\"])();var _wllama_debug=Module[\\\"_wllama_debug\\\"]=()=>(_wllama_debug=Module[\\\"_wllama_debug\\\"]=wasmExports[\\\"I\\\"])();var _main=Module[\\\"_main\\\"]=(a0,a1)=>(_main=Module[\\\"_main\\\"]=wasmExports[\\\"J\\\"])(a0,a1);var __emscripten_tls_init=Module[\\\"__emscripten_tls_init\\\"]=()=>(__emscripten_tls_init=Module[\\\"__emscripten_tls_init\\\"]=wasmExports[\\\"K\\\"])();var _pthread_self=Module[\\\"_pthread_self\\\"]=()=>(_pthread_self=Module[\\\"_pthread_self\\\"]=wasmExports[\\\"L\\\"])();var _emscripten_builtin_memalign=(a0,a1)=>(_emscripten_builtin_memalign=wasmExports[\\\"M\\\"])(a0,a1);var __emscripten_thread_init=Module[\\\"__emscripten_thread_init\\\"]=(a0,a1,a2,a3,a4,a5)=>(__emscripten_thread_init=Module[\\\"__emscripten_thread_init\\\"]=wasmExports[\\\"O\\\"])(a0,a1,a2,a3,a4,a5);var __emscripten_thread_crashed=Module[\\\"__emscripten_thread_crashed\\\"]=()=>(__emscripten_thread_crashed=Module[\\\"__emscripten_thread_crashed\\\"]=wasmExports[\\\"P\\\"])();var _emscripten_main_thread_process_queued_calls=()=>(_emscripten_main_thread_process_queued_calls=wasmExports[\\\"Q\\\"])();var _emscripten_main_runtime_thread_id=()=>(_emscripten_main_runtime_thread_id=wasmExports[\\\"R\\\"])();var __emscripten_run_on_main_thread_js=(a0,a1,a2,a3,a4)=>(__emscripten_run_on_main_thread_js=wasmExports[\\\"S\\\"])(a0,a1,a2,a3,a4);var __emscripten_thread_free_data=a0=>(__emscripten_thread_free_data=wasmExports[\\\"T\\\"])(a0);var __emscripten_thread_exit=Module[\\\"__emscripten_thread_exit\\\"]=a0=>(__emscripten_thread_exit=Module[\\\"__emscripten_thread_exit\\\"]=wasmExports[\\\"U\\\"])(a0);var __emscripten_check_mailbox=()=>(__emscripten_check_mailbox=wasmExports[\\\"V\\\"])();var ___trap=()=>(___trap=wasmExports[\\\"W\\\"])();var setTempRet0=a0=>(setTempRet0=wasmExports[\\\"X\\\"])(a0);var _emscripten_stack_set_limits=(a0,a1)=>(_emscripten_stack_set_limits=wasmExports[\\\"Y\\\"])(a0,a1);var stackSave=()=>(stackSave=wasmExports[\\\"Z\\\"])();var stackRestore=a0=>(stackRestore=wasmExports[\\\"_\\\"])(a0);var stackAlloc=a0=>(stackAlloc=wasmExports[\\\"$\\\"])(a0);var dynCall_jiji=Module[\\\"dynCall_jiji\\\"]=(a0,a1,a2,a3,a4)=>(dynCall_jiji=Module[\\\"dynCall_jiji\\\"]=wasmExports[\\\"aa\\\"])(a0,a1,a2,a3,a4);var dynCall_viij=Module[\\\"dynCall_viij\\\"]=(a0,a1,a2,a3,a4)=>(dynCall_viij=Module[\\\"dynCall_viij\\\"]=wasmExports[\\\"ba\\\"])(a0,a1,a2,a3,a4);var dynCall_viijii=Module[\\\"dynCall_viijii\\\"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_viijii=Module[\\\"dynCall_viijii\\\"]=wasmExports[\\\"ca\\\"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_iiiiij=Module[\\\"dynCall_iiiiij\\\"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_iiiiij=Module[\\\"dynCall_iiiiij\\\"]=wasmExports[\\\"da\\\"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_iiiiijj=Module[\\\"dynCall_iiiiijj\\\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8)=>(dynCall_iiiiijj=Module[\\\"dynCall_iiiiijj\\\"]=wasmExports[\\\"ea\\\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8);var dynCall_iiiiiijj=Module[\\\"dynCall_iiiiiijj\\\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)=>(dynCall_iiiiiijj=Module[\\\"dynCall_iiiiiijj\\\"]=wasmExports[\\\"fa\\\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);function applySignatureConversions(wasmExports){wasmExports=Object.assign({},wasmExports);var makeWrapper_p=f=>()=>f()>>>0;var makeWrapper_ppp=f=>(a0,a1)=>f(a0,a1)>>>0;var makeWrapper_pp=f=>a0=>f(a0)>>>0;wasmExports[\\\"L\\\"]=makeWrapper_p(wasmExports[\\\"L\\\"]);wasmExports[\\\"M\\\"]=makeWrapper_ppp(wasmExports[\\\"M\\\"]);wasmExports[\\\"R\\\"]=makeWrapper_p(wasmExports[\\\"R\\\"]);wasmExports[\\\"Z\\\"]=makeWrapper_p(wasmExports[\\\"Z\\\"]);wasmExports[\\\"$\\\"]=makeWrapper_pp(wasmExports[\\\"$\\\"]);return wasmExports}Module[\\\"addRunDependency\\\"]=addRunDependency;Module[\\\"removeRunDependency\\\"]=removeRunDependency;Module[\\\"FS_createPath\\\"]=FS.createPath;Module[\\\"FS_createLazyFile\\\"]=FS.createLazyFile;Module[\\\"FS_createDevice\\\"]=FS.createDevice;Module[\\\"wasmMemory\\\"]=wasmMemory;Module[\\\"keepRuntimeAlive\\\"]=keepRuntimeAlive;Module[\\\"ccall\\\"]=ccall;Module[\\\"cwrap\\\"]=cwrap;Module[\\\"ExitStatus\\\"]=ExitStatus;Module[\\\"FS_createPreloadedFile\\\"]=FS.createPreloadedFile;Module[\\\"FS_createDataFile\\\"]=FS.createDataFile;Module[\\\"FS_unlink\\\"]=FS.unlink;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){return}if(ENVIRONMENT_IS_PTHREAD){initRuntime();startWorker(Module);return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\\\"calledRun\\\"]=true;if(ABORT)return;initRuntime();preMain();if(Module[\\\"onRuntimeInitialized\\\"])Module[\\\"onRuntimeInitialized\\\"]();if(shouldRunNow)callMain();postRun()}if(Module[\\\"setStatus\\\"]){Module[\\\"setStatus\\\"](\\\"Running...\\\");setTimeout(function(){setTimeout(function(){Module[\\\"setStatus\\\"](\\\"\\\")},1);doRun()},1)}else{doRun()}}if(Module[\\\"preInit\\\"]){if(typeof Module[\\\"preInit\\\"]==\\\"function\\\")Module[\\\"preInit\\\"]=[Module[\\\"preInit\\\"]];while(Module[\\\"preInit\\\"].length>0){Module[\\\"preInit\\\"].pop()()}}var shouldRunNow=true;if(Module[\\\"noInitialRun\\\"])shouldRunNow=false;run();\\n\";\nconst WLLAMA_MULTI_THREAD_WORKER_CODE = \"\\\"use strict\\\";var Module={};var ENVIRONMENT_IS_NODE=typeof process==\\\"object\\\"&&typeof process.versions==\\\"object\\\"&&typeof process.versions.node==\\\"string\\\";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require(\\\"worker_threads\\\");var parentPort=nodeWorkerThreads.parentPort;parentPort.on(\\\"message\\\",data=>onmessage({data:data}));var fs=require(\\\"fs\\\");var vm=require(\\\"vm\\\");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:f=>vm.runInThisContext(fs.readFileSync(f,\\\"utf8\\\"),{filename:f}),postMessage:msg=>parentPort.postMessage(msg),performance:global.performance||{now:Date.now}})}var initializedJS=false;function threadPrintErr(...args){var text=args.join(\\\" \\\");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+\\\"\\\\n\\\");return}console.error(text)}function threadAlert(...args){var text=args.join(\\\" \\\");postMessage({cmd:\\\"alert\\\",text:text,threadId:Module[\\\"_pthread_self\\\"]()})}var err=threadPrintErr;self.alert=threadAlert;Module[\\\"instantiateWasm\\\"]=(info,receiveInstance)=>{var module=Module[\\\"wasmModule\\\"];Module[\\\"wasmModule\\\"]=null;var instance=new WebAssembly.Instance(module,info);return receiveInstance(instance)};self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd===\\\"load\\\"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{postMessage({\\\"cmd\\\":\\\"loaded\\\"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};Module[\\\"wasmModule\\\"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=(...args)=>{postMessage({cmd:\\\"callHandler\\\",handler:handler,args:args})}}Module[\\\"wasmMemory\\\"]=e.data.wasmMemory;Module[\\\"buffer\\\"]=Module[\\\"wasmMemory\\\"].buffer;Module[\\\"ENVIRONMENT_IS_PTHREAD\\\"]=true;if(typeof e.data.urlOrBlob==\\\"string\\\"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}}else if(e.data.cmd===\\\"run\\\"){Module[\\\"__emscripten_thread_init\\\"](e.data.pthread_ptr,0,0,1);Module[\\\"__emscripten_thread_mailbox_await\\\"](e.data.pthread_ptr);Module[\\\"establishStackSpace\\\"]();Module[\\\"PThread\\\"].receiveObjectTransfer(e.data);Module[\\\"PThread\\\"].threadInitTLS();if(!initializedJS){initializedJS=true}try{Module[\\\"invokeEntryPoint\\\"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!=\\\"unwind\\\"){throw ex}}}else if(e.data.cmd===\\\"cancel\\\"){if(Module[\\\"_pthread_self\\\"]()){Module[\\\"__emscripten_thread_exit\\\"](-1)}}else if(e.data.target===\\\"setimmediate\\\"){}else if(e.data.cmd===\\\"checkMailbox\\\"){if(initializedJS){Module[\\\"checkMailbox\\\"]()}}else if(e.data.cmd){err(`worker.js received unknown command ${e.data.cmd}`);err(e.data)}}catch(ex){Module[\\\"__emscripten_thread_crashed\\\"]?.();throw ex}}self.onmessage=handleMessage;\\n\";\nconst WLLAMA_SINGLE_THREAD_CODE = \"var Module=typeof Module!=\\\"undefined\\\"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\\\"./this.program\\\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window==\\\"object\\\";var ENVIRONMENT_IS_WORKER=typeof importScripts==\\\"function\\\";var ENVIRONMENT_IS_NODE=typeof process==\\\"object\\\"&&typeof process.versions==\\\"object\\\"&&typeof process.versions.node==\\\"string\\\";var scriptDirectory=\\\"\\\";function locateFile(path){if(Module[\\\"locateFile\\\"]){return Module[\\\"locateFile\\\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;if(ENVIRONMENT_IS_NODE){var fs=require(\\\"fs\\\");var nodePath=require(\\\"path\\\");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+\\\"/\\\"}else{scriptDirectory=__dirname+\\\"/\\\"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:\\\"utf8\\\")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:\\\"utf8\\\",(err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)})};if(!Module[\\\"thisProgram\\\"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")}arguments_=process.argv.slice(2);if(typeof module!=\\\"undefined\\\"){module[\\\"exports\\\"]=Module}process.on(\\\"uncaughtException\\\",ex=>{if(ex!==\\\"unwind\\\"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}});quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\\\"undefined\\\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.startsWith(\\\"blob:\\\")){scriptDirectory=\\\"\\\"}else{scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1)}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);xhr.responseType=\\\"arraybuffer\\\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,true);xhr.responseType=\\\"arraybuffer\\\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}}else{}var out=Module[\\\"print\\\"]||console.log.bind(console);var err=Module[\\\"printErr\\\"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\\\"arguments\\\"])arguments_=Module[\\\"arguments\\\"];if(Module[\\\"thisProgram\\\"])thisProgram=Module[\\\"thisProgram\\\"];if(Module[\\\"quit\\\"])quit_=Module[\\\"quit\\\"];var wasmBinary;if(Module[\\\"wasmBinary\\\"])wasmBinary=Module[\\\"wasmBinary\\\"];if(typeof WebAssembly!=\\\"object\\\"){abort(\\\"no native wasm support detected\\\")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module[\\\"HEAP8\\\"]=HEAP8=new Int8Array(b);Module[\\\"HEAP16\\\"]=HEAP16=new Int16Array(b);Module[\\\"HEAPU8\\\"]=HEAPU8=new Uint8Array(b);Module[\\\"HEAPU16\\\"]=HEAPU16=new Uint16Array(b);Module[\\\"HEAP32\\\"]=HEAP32=new Int32Array(b);Module[\\\"HEAPU32\\\"]=HEAPU32=new Uint32Array(b);Module[\\\"HEAPF32\\\"]=HEAPF32=new Float32Array(b);Module[\\\"HEAPF64\\\"]=HEAPF64=new Float64Array(b)}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module[\\\"preRun\\\"]){if(typeof Module[\\\"preRun\\\"]==\\\"function\\\")Module[\\\"preRun\\\"]=[Module[\\\"preRun\\\"]];while(Module[\\\"preRun\\\"].length){addOnPreRun(Module[\\\"preRun\\\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(!Module[\\\"noFSInit\\\"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;TTY.init();callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module[\\\"postRun\\\"]){if(typeof Module[\\\"postRun\\\"]==\\\"function\\\")Module[\\\"postRun\\\"]=[Module[\\\"postRun\\\"]];while(Module[\\\"postRun\\\"].length){addOnPostRun(Module[\\\"postRun\\\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies)}function removeRunDependency(id){runDependencies--;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){Module[\\\"onAbort\\\"]?.(what);what=\\\"Aborted(\\\"+what+\\\")\\\";err(what);ABORT=true;EXITSTATUS=1;what+=\\\". Build with -sASSERTIONS for more info.\\\";if(runtimeInitialized){___trap()}var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix=\\\"data:application/octet-stream;base64,\\\";var isDataURI=filename=>filename.startsWith(dataURIPrefix);var isFileURI=filename=>filename.startsWith(\\\"file://\\\");var wasmBinaryFile;wasmBinaryFile=\\\"wllama.wasm\\\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\\\"both async and sync fetching of the wasm failed\\\"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\\\"function\\\"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:\\\"same-origin\\\"}).then(response=>{if(!response[\\\"ok\\\"]){throw`failed to load wasm binary file at '${binaryFile}'`}return response[\\\"arrayBuffer\\\"]()}).catch(()=>getBinarySync(binaryFile))}else if(readAsync){return new Promise((resolve,reject)=>{readAsync(binaryFile,response=>resolve(new Uint8Array(response)),reject)})}}return Promise.resolve().then(()=>getBinarySync(binaryFile))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)})}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming==\\\"function\\\"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch==\\\"function\\\"){return fetch(binaryFile,{credentials:\\\"same-origin\\\"}).then(response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){err(`wasm streaming compile failed: ${reason}`);err(\\\"falling back to ArrayBuffer instantiation\\\");return instantiateArrayBuffer(binaryFile,imports,callback)})})}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={\\\"a\\\":wasmImports};function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=applySignatureConversions(wasmExports);wasmMemory=wasmExports[\\\"t\\\"];updateMemoryViews();addOnInit(wasmExports[\\\"u\\\"]);removeRunDependency(\\\"wasm-instantiate\\\");return wasmExports}addRunDependency(\\\"wasm-instantiate\\\");function receiveInstantiationResult(result){receiveInstance(result[\\\"instance\\\"])}if(Module[\\\"instantiateWasm\\\"]){try{return Module[\\\"instantiateWasm\\\"](info,receiveInstance)}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}var tempDouble;var tempI64;function ExitStatus(status){this.name=\\\"ExitStatus\\\";this.message=`Program terminated with exit(${status})`;this.status=status}Module[\\\"ExitStatus\\\"]=ExitStatus;var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};Module[\\\"callRuntimeCallbacks\\\"]=callRuntimeCallbacks;function getValue(ptr,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":return HEAP8[ptr>>>0];case\\\"i8\\\":return HEAP8[ptr>>>0];case\\\"i16\\\":return HEAP16[ptr>>>1>>>0];case\\\"i32\\\":return HEAP32[ptr>>>2>>>0];case\\\"i64\\\":abort(\\\"to do getValue(i64) use WASM_BIGINT\\\");case\\\"float\\\":return HEAPF32[ptr>>>2>>>0];case\\\"double\\\":return HEAPF64[ptr>>>3>>>0];case\\\"*\\\":return HEAPU32[ptr>>>2>>>0];default:abort(`invalid type for getValue: ${type}`)}}Module[\\\"getValue\\\"]=getValue;var noExitRuntime=Module[\\\"noExitRuntime\\\"]||true;Module[\\\"noExitRuntime\\\"]=noExitRuntime;function setValue(ptr,value,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":HEAP8[ptr>>>0]=value;break;case\\\"i8\\\":HEAP8[ptr>>>0]=value;break;case\\\"i16\\\":HEAP16[ptr>>>1>>>0]=value;break;case\\\"i32\\\":HEAP32[ptr>>>2>>>0]=value;break;case\\\"i64\\\":abort(\\\"to do setValue(i64) use WASM_BIGINT\\\");case\\\"float\\\":HEAPF32[ptr>>>2>>>0]=value;break;case\\\"double\\\":HEAPF64[ptr>>>3>>>0]=value;break;case\\\"*\\\":HEAPU32[ptr>>>2>>>0]=value;break;default:abort(`invalid type for setValue: ${type}`)}}Module[\\\"setValue\\\"]=setValue;var PATH={isAbs:path=>path.charAt(0)===\\\"/\\\",splitPath:filename=>{var splitPathRe=/^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\\\".\\\"){parts.splice(i,1)}else if(last===\\\"..\\\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\\\"..\\\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)===\\\"/\\\";path=PATH.normalizeArray(path.split(\\\"/\\\").filter(p=>!!p),!isAbsolute).join(\\\"/\\\");if(!path&&!isAbsolute){path=\\\".\\\"}if(path&&trailingSlash){path+=\\\"/\\\"}return(isAbsolute?\\\"/\\\":\\\"\\\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\\\".\\\"}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:path=>{if(path===\\\"/\\\")return\\\"/\\\";path=PATH.normalize(path);path=path.replace(/\\\\/$/,\\\"\\\");var lastSlash=path.lastIndexOf(\\\"/\\\");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:(...paths)=>PATH.normalize(paths.join(\\\"/\\\")),join2:(l,r)=>PATH.normalize(l+\\\"/\\\"+r)};Module[\\\"PATH\\\"]=PATH;var initRandomFill=()=>{if(typeof crypto==\\\"object\\\"&&typeof crypto[\\\"getRandomValues\\\"]==\\\"function\\\"){return view=>crypto.getRandomValues(view)}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=require(\\\"crypto\\\");var randomFillSync=crypto_module[\\\"randomFillSync\\\"];if(randomFillSync){return view=>crypto_module[\\\"randomFillSync\\\"](view)}var randomBytes=crypto_module[\\\"randomBytes\\\"];return view=>(view.set(randomBytes(view.byteLength)),view)}catch(e){}}abort(\\\"initRandomDevice\\\")};Module[\\\"initRandomFill\\\"]=initRandomFill;var randomFill=view=>(randomFill=initRandomFill())(view);Module[\\\"randomFill\\\"]=randomFill;var PATH_FS={resolve:(...args)=>{var resolvedPath=\\\"\\\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\\\"string\\\"){throw new TypeError(\\\"Arguments to path.resolve must be strings\\\")}else if(!path){return\\\"\\\"}resolvedPath=path+\\\"/\\\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\\\"/\\\").filter(p=>!!p),!resolvedAbsolute).join(\\\"/\\\");return(resolvedAbsolute?\\\"/\\\":\\\"\\\")+resolvedPath||\\\".\\\"},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\\\"\\\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\\\"\\\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\\\"/\\\"));var toParts=trim(to.split(\\\"/\\\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\\\"..\\\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\\\"/\\\")}};Module[\\\"PATH_FS\\\"]=PATH_FS;var UTF8Decoder=typeof TextDecoder!=\\\"undefined\\\"?new TextDecoder(\\\"utf8\\\"):undefined;Module[\\\"UTF8Decoder\\\"]=UTF8Decoder;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\\\"\\\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};Module[\\\"UTF8ArrayToString\\\"]=UTF8ArrayToString;var FS_stdin_getChar_buffer=[];Module[\\\"FS_stdin_getChar_buffer\\\"]=FS_stdin_getChar_buffer;var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};Module[\\\"lengthBytesUTF8\\\"]=lengthBytesUTF8;var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{outIdx>>>=0;if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}}heap[outIdx>>>0]=0;return outIdx-startIdx};Module[\\\"stringToUTF8Array\\\"]=stringToUTF8Array;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}Module[\\\"intArrayFromString\\\"]=intArrayFromString;var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;var fd=process.stdin.fd;try{bytesRead=fs.readSync(fd,buf)}catch(e){if(e.toString().includes(\\\"EOF\\\"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString(\\\"utf-8\\\")}else{result=null}}else if(typeof window!=\\\"undefined\\\"&&typeof window.prompt==\\\"function\\\"){result=window.prompt(\\\"Input: \\\");if(result!==null){result+=\\\"\\\\n\\\"}}else if(typeof readline==\\\"function\\\"){result=readline();if(result!==null){result+=\\\"\\\\n\\\"}}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};Module[\\\"FS_stdin_getChar\\\"]=FS_stdin_getChar;var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};Module[\\\"TTY\\\"]=TTY;var zeroMemory=(address,size)=>{HEAPU8.fill(0,address,address+size);return address};Module[\\\"zeroMemory\\\"]=zeroMemory;var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;Module[\\\"alignMemory\\\"]=alignMemory;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;return zeroMemory(ptr,size)};Module[\\\"mmapAlloc\\\"]=mmapAlloc;var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\\\"/\\\",16384|511,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){throw FS.genericErrors[44]},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir},unlink(parent,name){delete parent.contents[name];parent.timestamp=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now()},readdir(node){var entries=[\\\".\\\",\\\"..\\\"];for(var key of Object.keys(node.contents)){entries.push(key)}return entries},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===HEAP8.buffer){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}HEAP8.set(contents,ptr>>>0)}return{ptr:ptr,allocated:allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};Module[\\\"MEMFS\\\"]=MEMFS;var asyncLoad=(url,onload,onerror,noRunDep)=>{var dep=!noRunDep?getUniqueRunDependency(`al ${url}`):\\\"\\\";readAsync(url,arrayBuffer=>{onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep)},event=>{if(onerror){onerror()}else{throw`Loading data file \\\"${url}\\\" failed.`}});if(dep)addRunDependency(dep)};Module[\\\"asyncLoad\\\"]=asyncLoad;var FS_createDataFile=(parent,name,fileData,canRead,canWrite,canOwn)=>{FS.createDataFile(parent,name,fileData,canRead,canWrite,canOwn)};Module[\\\"FS_createDataFile\\\"]=FS_createDataFile;var preloadPlugins=Module[\\\"preloadPlugins\\\"]||[];Module[\\\"preloadPlugins\\\"]=preloadPlugins;var FS_handledByPreloadPlugin=(byteArray,fullname,finish,onerror)=>{if(typeof Browser!=\\\"undefined\\\")Browser.init();var handled=false;preloadPlugins.forEach(plugin=>{if(handled)return;if(plugin[\\\"canHandle\\\"](fullname)){plugin[\\\"handle\\\"](byteArray,fullname,finish,onerror);handled=true}});return handled};Module[\\\"FS_handledByPreloadPlugin\\\"]=FS_handledByPreloadPlugin;var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);function processData(byteArray){function finish(byteArray){preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}onload?.();removeRunDependency(dep)}if(FS_handledByPreloadPlugin(byteArray,fullname,finish,()=>{onerror?.();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url==\\\"string\\\"){asyncLoad(url,processData,onerror)}else{processData(url)}};Module[\\\"FS_createPreloadedFile\\\"]=FS_createPreloadedFile;var FS_modeStringToFlags=str=>{var flagModes={\\\"r\\\":0,\\\"r+\\\":2,\\\"w\\\":512|64|1,\\\"w+\\\":512|64|2,\\\"a\\\":1024|64|1,\\\"a+\\\":1024|64|2};var flags=flagModes[str];if(typeof flags==\\\"undefined\\\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};Module[\\\"FS_modeStringToFlags\\\"]=FS_modeStringToFlags;var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};Module[\\\"FS_getMode\\\"]=FS_getMode;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\\\"/\\\",initialized:false,ignorePermissions:true,ErrnoError:class{constructor(errno){this.name=\\\"ErrnoError\\\";this.errno=errno}},genericErrors:{},filesystems:null,syncFSRequests:0,FSStream:class{constructor(){this.shared={}}get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;this.readMode=292|73;this.writeMode=146}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){path=PATH_FS.resolve(path);if(!path)return{path:\\\"\\\",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=path.split(\\\"/\\\").filter(p=>!!p);var current=FS.root;var current_path=\\\"/\\\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return{path:current_path,node:current}},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\\\"/\\\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\\\"r\\\",\\\"w\\\",\\\"rw\\\"][flag&3];if(flag&512){perms+=\\\"w\\\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\\\"r\\\")&&!(node.mode&292)){return 2}else if(perms.includes(\\\"w\\\")&&!(node.mode&146)){return 2}else if(perms.includes(\\\"x\\\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\\\"x\\\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\\\"wx\\\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\\\"wx\\\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!==\\\"r\\\"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\\\"function\\\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount(type,opts,mountpoint){var root=mountpoint===\\\"/\\\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name===\\\".\\\"||name===\\\"..\\\"){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\\\"/\\\");var d=\\\"\\\";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+=\\\"/\\\"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\\\"undefined\\\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat(path){return FS.stat(path,true)},chmod(path,mode,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.chmod(stream.node,mode)},chown(path,uid,gid,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.chown(stream.node,uid,gid)},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open(path,flags,mode){if(path===\\\"\\\"){throw new FS.ErrnoError(44)}flags=typeof flags==\\\"string\\\"?FS_modeStringToFlags(flags):flags;mode=typeof mode==\\\"undefined\\\"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==\\\"object\\\"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module[\\\"logReadFiles\\\"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\\\"binary\\\";if(opts.encoding!==\\\"utf8\\\"&&opts.encoding!==\\\"binary\\\"){throw new Error(`Invalid encoding type \\\"${opts.encoding}\\\"`)}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\\\"utf8\\\"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding===\\\"binary\\\"){ret=buf}FS.close(stream);return ret},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\\\"string\\\"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error(\\\"Unsupported data type\\\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\\\"x\\\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\\\"/tmp\\\");FS.mkdir(\\\"/home\\\");FS.mkdir(\\\"/home/web_user\\\")},createDefaultDevices(){FS.mkdir(\\\"/dev\\\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev(\\\"/dev/null\\\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\\\"/dev/tty\\\",FS.makedev(5,0));FS.mkdev(\\\"/dev/tty1\\\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomLeft=randomFill(randomBuffer).byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\\\"/dev\\\",\\\"random\\\",randomByte);FS.createDevice(\\\"/dev\\\",\\\"urandom\\\",randomByte);FS.mkdir(\\\"/dev/shm\\\");FS.mkdir(\\\"/dev/shm/tmp\\\")},createSpecialDirectories(){FS.mkdir(\\\"/proc\\\");var proc_self=FS.mkdir(\\\"/proc/self\\\");FS.mkdir(\\\"/proc/self/fd\\\");FS.mount({mount(){var node=FS.createNode(proc_self,\\\"fd\\\",16384|511,73);node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\\\"fake\\\"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},\\\"/proc/self/fd\\\")},createStandardStreams(){if(Module[\\\"stdin\\\"]){FS.createDevice(\\\"/dev\\\",\\\"stdin\\\",Module[\\\"stdin\\\"])}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdin\\\")}if(Module[\\\"stdout\\\"]){FS.createDevice(\\\"/dev\\\",\\\"stdout\\\",null,Module[\\\"stdout\\\"])}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdout\\\")}if(Module[\\\"stderr\\\"]){FS.createDevice(\\\"/dev\\\",\\\"stderr\\\",null,Module[\\\"stderr\\\"])}else{FS.symlink(\\\"/dev/tty1\\\",\\\"/dev/stderr\\\")}var stdin=FS.open(\\\"/dev/stdin\\\",0);var stdout=FS.open(\\\"/dev/stdout\\\",1);var stderr=FS.open(\\\"/dev/stderr\\\",1)},staticInit(){[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack=\\\"<generic error, no stack>\\\"});FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\\\"/\\\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={\\\"MEMFS\\\":MEMFS}},init(input,output,error){FS.init.initialized=true;Module[\\\"stdin\\\"]=input||Module[\\\"stdin\\\"];Module[\\\"stdout\\\"]=output||Module[\\\"stdout\\\"];Module[\\\"stderr\\\"]=error||Module[\\\"stderr\\\"];FS.createStandardStreams()},quit(){FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\\\"/\\\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);var parts=path.split(\\\"/\\\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\\\"string\\\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!=\\\"undefined\\\"){throw new Error(\\\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\\\")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}else{throw new Error(\\\"Cannot load without read() or XMLHttpRequest.\\\")}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{constructor(){this.lengthKnown=false;this.chunks=[]}get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\\\"HEAD\\\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);var datalength=Number(xhr.getResponseHeader(\\\"Content-length\\\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\\\"Accept-Ranges\\\"))&&header===\\\"bytes\\\";var usesGzip=(header=xhr.getResponseHeader(\\\"Content-Encoding\\\"))&&header===\\\"gzip\\\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error(\\\"invalid range (\\\"+from+\\\", \\\"+to+\\\") or no bytes requested!\\\");if(to>datalength-1)throw new Error(\\\"only \\\"+datalength+\\\" bytes available! programmer error!\\\");var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\\\"Range\\\",\\\"bytes=\\\"+from+\\\"-\\\"+to);xhr.responseType=\\\"arraybuffer\\\";if(xhr.overrideMimeType){xhr.overrideMimeType(\\\"text/plain; charset=x-user-defined\\\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\\\"\\\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\")throw new Error(\\\"doXHR failed!\\\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\\\"LazyFiles on gzip forces download of the whole file when length is accessed\\\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(typeof XMLHttpRequest!=\\\"undefined\\\"){if(!ENVIRONMENT_IS_WORKER)throw\\\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\\\";var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr:ptr,allocated:true}};node.stream_ops=stream_ops;return node}};Module[\\\"FS\\\"]=FS;var UTF8ToString=(ptr,maxBytesToRead)=>{ptr>>>=0;return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\\\"\\\"};Module[\\\"UTF8ToString\\\"]=UTF8ToString;var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat(func,path,buf){var stat=func(path);HEAP32[buf>>>2>>>0]=stat.dev;HEAP32[buf+4>>>2>>>0]=stat.mode;HEAPU32[buf+8>>>2>>>0]=stat.nlink;HEAP32[buf+12>>>2>>>0]=stat.uid;HEAP32[buf+16>>>2>>>0]=stat.gid;HEAP32[buf+20>>>2>>>0]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>>2>>>0]=tempI64[0],HEAP32[buf+28>>>2>>>0]=tempI64[1];HEAP32[buf+32>>>2>>>0]=4096;HEAP32[buf+36>>>2>>>0]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>>2>>>0]=tempI64[0],HEAP32[buf+44>>>2>>>0]=tempI64[1];HEAPU32[buf+48>>>2>>>0]=atime%1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>>2>>>0]=tempI64[0],HEAP32[buf+60>>>2>>>0]=tempI64[1];HEAPU32[buf+64>>>2>>>0]=mtime%1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>>2>>>0]=tempI64[0],HEAP32[buf+76>>>2>>>0]=tempI64[1];HEAPU32[buf+80>>>2>>>0]=ctime%1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>>2>>>0]=tempI64[0],HEAP32[buf+92>>>2>>>0]=tempI64[1];return 0},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},varargs:undefined,get(){var ret=HEAP32[+SYSCALLS.varargs>>>2>>>0];SYSCALLS.varargs+=4;return ret},getp(){return SYSCALLS.get()},getStr(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream}};Module[\\\"SYSCALLS\\\"]=SYSCALLS;var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;Module[\\\"convertI32PairToI53Checked\\\"]=convertI32PairToI53Checked;function ___syscall_fcntl64(fd,cmd,varargs){varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 12:{var arg=SYSCALLS.getp();var offset=0;HEAP16[arg+offset>>>1>>>0]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_fcntl64\\\"]=___syscall_fcntl64;function ___syscall_ioctl(fd,op,varargs){varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:{if(!stream.tty)return-59;return 0}case 21505:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcgets){var termios=stream.tty.ops.ioctl_tcgets(stream);var argp=SYSCALLS.getp();HEAP32[argp>>>2>>>0]=termios.c_iflag||0;HEAP32[argp+4>>>2>>>0]=termios.c_oflag||0;HEAP32[argp+8>>>2>>>0]=termios.c_cflag||0;HEAP32[argp+12>>>2>>>0]=termios.c_lflag||0;for(var i=0;i<32;i++){HEAP8[argp+i+17>>>0]=termios.c_cc[i]||0}return 0}return 0}case 21510:case 21511:case 21512:{if(!stream.tty)return-59;return 0}case 21506:case 21507:case 21508:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcsets){var argp=SYSCALLS.getp();var c_iflag=HEAP32[argp>>>2>>>0];var c_oflag=HEAP32[argp+4>>>2>>>0];var c_cflag=HEAP32[argp+8>>>2>>>0];var c_lflag=HEAP32[argp+12>>>2>>>0];var c_cc=[];for(var i=0;i<32;i++){c_cc.push(HEAP8[argp+i+17>>>0])}return stream.tty.ops.ioctl_tcsets(stream.tty,op,{c_iflag:c_iflag,c_oflag:c_oflag,c_cflag:c_cflag,c_lflag:c_lflag,c_cc:c_cc})}return 0}case 21519:{if(!stream.tty)return-59;var argp=SYSCALLS.getp();HEAP32[argp>>>2>>>0]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=SYSCALLS.getp();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tiocgwinsz){var winsize=stream.tty.ops.ioctl_tiocgwinsz(stream.tty);var argp=SYSCALLS.getp();HEAP16[argp>>>1>>>0]=winsize[0];HEAP16[argp+2>>>1>>>0]=winsize[1]}return 0}case 21524:{if(!stream.tty)return-59;return 0}case 21515:{if(!stream.tty)return-59;return 0}default:return-28}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_ioctl\\\"]=___syscall_ioctl;function ___syscall_openat(dirfd,path,flags,varargs){path>>>=0;varargs>>>=0;SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_openat\\\"]=___syscall_openat;var nowIsMonotonic=1;Module[\\\"nowIsMonotonic\\\"]=nowIsMonotonic;var __emscripten_get_now_is_monotonic=()=>nowIsMonotonic;Module[\\\"__emscripten_get_now_is_monotonic\\\"]=__emscripten_get_now_is_monotonic;function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);allocated>>>=0;addr>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>>2>>>0]=res.allocated;HEAPU32[addr>>>2>>>0]=ptr;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__mmap_js\\\"]=__mmap_js;function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){addr>>>=0;len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__munmap_js\\\"]=__munmap_js;var _abort=()=>{abort(\\\"\\\")};Module[\\\"_abort\\\"]=_abort;var _emscripten_date_now=()=>Date.now();Module[\\\"_emscripten_date_now\\\"]=_emscripten_date_now;var _emscripten_get_now;_emscripten_get_now=()=>performance.now();Module[\\\"_emscripten_get_now\\\"]=_emscripten_get_now;function _emscripten_memcpy_js(dest,src,num){dest>>>=0;src>>>=0;num>>>=0;return HEAPU8.copyWithin(dest>>>0,src>>>0,src+num>>>0)}Module[\\\"_emscripten_memcpy_js\\\"]=_emscripten_memcpy_js;var getHeapMax=()=>4294901760;Module[\\\"getHeapMax\\\"]=getHeapMax;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};Module[\\\"growMemory\\\"]=growMemory;function _emscripten_resize_heap(requestedSize){requestedSize>>>=0;var oldSize=HEAPU8.length;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false}Module[\\\"_emscripten_resize_heap\\\"]=_emscripten_resize_heap;var ENV={};Module[\\\"ENV\\\"]=ENV;var getExecutableName=()=>thisProgram||\\\"./this.program\\\";Module[\\\"getExecutableName\\\"]=getExecutableName;var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(typeof navigator==\\\"object\\\"&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\";var env={\\\"USER\\\":\\\"web_user\\\",\\\"LOGNAME\\\":\\\"web_user\\\",\\\"PATH\\\":\\\"/\\\",\\\"PWD\\\":\\\"/\\\",\\\"HOME\\\":\\\"/home/web_user\\\",\\\"LANG\\\":lang,\\\"_\\\":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};Module[\\\"getEnvStrings\\\"]=getEnvStrings;var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){HEAP8[buffer++>>>0]=str.charCodeAt(i)}HEAP8[buffer>>>0]=0};Module[\\\"stringToAscii\\\"]=stringToAscii;var _environ_get=function(__environ,environ_buf){__environ>>>=0;environ_buf>>>=0;var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>>2>>>0]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1});return 0};Module[\\\"_environ_get\\\"]=_environ_get;var _environ_sizes_get=function(penviron_count,penviron_buf_size){penviron_count>>>=0;penviron_buf_size>>>=0;var strings=getEnvStrings();HEAPU32[penviron_count>>>2>>>0]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);HEAPU32[penviron_buf_size>>>2>>>0]=bufSize;return 0};Module[\\\"_environ_sizes_get\\\"]=_environ_sizes_get;function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_close\\\"]=_fd_close;var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2>>>0];var len=HEAPU32[iov+4>>>2>>>0];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!==\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doReadv\\\"]=doReadv;function _fd_read(fd,iov,iovcnt,pnum){iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_read\\\"]=_fd_read;function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);newOffset>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>>2>>>0]=tempI64[0],HEAP32[newOffset+4>>>2>>>0]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_seek\\\"]=_fd_seek;var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2>>>0];var len=HEAPU32[iov+4>>>2>>>0];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(typeof offset!==\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doWritev\\\"]=doWritev;function _fd_write(fd,iov,iovcnt,pnum){iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_write\\\"]=_fd_write;function _getentropy(buffer,size){buffer>>>=0;size>>>=0;randomFill(HEAPU8.subarray(buffer>>>0,buffer+size>>>0));return 0}Module[\\\"_getentropy\\\"]=_getentropy;var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);Module[\\\"isLeapYear\\\"]=isLeapYear;var arraySum=(array,index)=>{var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum};Module[\\\"arraySum\\\"]=arraySum;var MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];Module[\\\"MONTH_DAYS_LEAP\\\"]=MONTH_DAYS_LEAP;var MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];Module[\\\"MONTH_DAYS_REGULAR\\\"]=MONTH_DAYS_REGULAR;var addDays=(date,days)=>{var newDate=new Date(date.getTime());while(days>0){var leap=isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate};Module[\\\"addDays\\\"]=addDays;var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer>>>0)};Module[\\\"writeArrayToMemory\\\"]=writeArrayToMemory;function _strftime(s,maxsize,format,tm){s>>>=0;maxsize>>>=0;format>>>=0;tm>>>=0;var tm_zone=HEAPU32[tm+40>>>2>>>0];var date={tm_sec:HEAP32[tm>>>2>>>0],tm_min:HEAP32[tm+4>>>2>>>0],tm_hour:HEAP32[tm+8>>>2>>>0],tm_mday:HEAP32[tm+12>>>2>>>0],tm_mon:HEAP32[tm+16>>>2>>>0],tm_year:HEAP32[tm+20>>>2>>>0],tm_wday:HEAP32[tm+24>>>2>>>0],tm_yday:HEAP32[tm+28>>>2>>>0],tm_isdst:HEAP32[tm+32>>>2>>>0],tm_gmtoff:HEAP32[tm+36>>>2>>>0],tm_zone:tm_zone?UTF8ToString(tm_zone):\\\"\\\"};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={\\\"%c\\\":\\\"%a %b %d %H:%M:%S %Y\\\",\\\"%D\\\":\\\"%m/%d/%y\\\",\\\"%F\\\":\\\"%Y-%m-%d\\\",\\\"%h\\\":\\\"%b\\\",\\\"%r\\\":\\\"%I:%M:%S %p\\\",\\\"%R\\\":\\\"%H:%M\\\",\\\"%T\\\":\\\"%H:%M:%S\\\",\\\"%x\\\":\\\"%m/%d/%y\\\",\\\"%X\\\":\\\"%H:%M:%S\\\",\\\"%Ec\\\":\\\"%c\\\",\\\"%EC\\\":\\\"%C\\\",\\\"%Ex\\\":\\\"%m/%d/%y\\\",\\\"%EX\\\":\\\"%H:%M:%S\\\",\\\"%Ey\\\":\\\"%y\\\",\\\"%EY\\\":\\\"%Y\\\",\\\"%Od\\\":\\\"%d\\\",\\\"%Oe\\\":\\\"%e\\\",\\\"%OH\\\":\\\"%H\\\",\\\"%OI\\\":\\\"%I\\\",\\\"%Om\\\":\\\"%m\\\",\\\"%OM\\\":\\\"%M\\\",\\\"%OS\\\":\\\"%S\\\",\\\"%Ou\\\":\\\"%u\\\",\\\"%OU\\\":\\\"%U\\\",\\\"%OV\\\":\\\"%V\\\",\\\"%Ow\\\":\\\"%w\\\",\\\"%OW\\\":\\\"%W\\\",\\\"%Oy\\\":\\\"%y\\\"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,\\\"g\\\"),EXPANSION_RULES_1[rule])}var WEEKDAYS=[\\\"Sunday\\\",\\\"Monday\\\",\\\"Tuesday\\\",\\\"Wednesday\\\",\\\"Thursday\\\",\\\"Friday\\\",\\\"Saturday\\\"];var MONTHS=[\\\"January\\\",\\\"February\\\",\\\"March\\\",\\\"April\\\",\\\"May\\\",\\\"June\\\",\\\"July\\\",\\\"August\\\",\\\"September\\\",\\\"October\\\",\\\"November\\\",\\\"December\\\"];function leadingSomething(value,digits,character){var str=typeof value==\\\"number\\\"?value.toString():value||\\\"\\\";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,\\\"0\\\")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}return thisDate.getFullYear()}return thisDate.getFullYear()-1}var EXPANSION_RULES_2={\\\"%a\\\":date=>WEEKDAYS[date.tm_wday].substring(0,3),\\\"%A\\\":date=>WEEKDAYS[date.tm_wday],\\\"%b\\\":date=>MONTHS[date.tm_mon].substring(0,3),\\\"%B\\\":date=>MONTHS[date.tm_mon],\\\"%C\\\":date=>{var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},\\\"%d\\\":date=>leadingNulls(date.tm_mday,2),\\\"%e\\\":date=>leadingSomething(date.tm_mday,2,\\\" \\\"),\\\"%g\\\":date=>getWeekBasedYear(date).toString().substring(2),\\\"%G\\\":getWeekBasedYear,\\\"%H\\\":date=>leadingNulls(date.tm_hour,2),\\\"%I\\\":date=>{var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},\\\"%j\\\":date=>leadingNulls(date.tm_mday+arraySum(isLeapYear(date.tm_year+1900)?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,date.tm_mon-1),3),\\\"%m\\\":date=>leadingNulls(date.tm_mon+1,2),\\\"%M\\\":date=>leadingNulls(date.tm_min,2),\\\"%n\\\":()=>\\\"\\\\n\\\",\\\"%p\\\":date=>{if(date.tm_hour>=0&&date.tm_hour<12){return\\\"AM\\\"}return\\\"PM\\\"},\\\"%S\\\":date=>leadingNulls(date.tm_sec,2),\\\"%t\\\":()=>\\\"\\\\t\\\",\\\"%u\\\":date=>date.tm_wday||7,\\\"%U\\\":date=>{var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},\\\"%V\\\":date=>{var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},\\\"%w\\\":date=>date.tm_wday,\\\"%W\\\":date=>{var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},\\\"%y\\\":date=>(date.tm_year+1900).toString().substring(2),\\\"%Y\\\":date=>date.tm_year+1900,\\\"%z\\\":date=>{var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?\\\"+\\\":\\\"-\\\")+String(\\\"0000\\\"+off).slice(-4)},\\\"%Z\\\":date=>date.tm_zone,\\\"%%\\\":()=>\\\"%\\\"};pattern=pattern.replace(/%%/g,\\\"\\\\0\\\\0\\\");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,\\\"g\\\"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\\\\0\\\\0/g,\\\"%\\\");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}Module[\\\"_strftime\\\"]=_strftime;function _strftime_l(s,maxsize,format,tm,loc){s>>>=0;maxsize>>>=0;format>>>=0;tm>>>=0;loc>>>=0;return _strftime(s,maxsize,format,tm)}Module[\\\"_strftime_l\\\"]=_strftime_l;var runtimeKeepaliveCounter=0;Module[\\\"runtimeKeepaliveCounter\\\"]=runtimeKeepaliveCounter;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;Module[\\\"keepRuntimeAlive\\\"]=keepRuntimeAlive;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module[\\\"onExit\\\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};Module[\\\"_proc_exit\\\"]=_proc_exit;var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};Module[\\\"exitJS\\\"]=exitJS;var handleException=e=>{if(e instanceof ExitStatus||e==\\\"unwind\\\"){return EXITSTATUS}quit_(1,e)};Module[\\\"handleException\\\"]=handleException;var getCFunc=ident=>{var func=Module[\\\"_\\\"+ident];return func};Module[\\\"getCFunc\\\"]=getCFunc;var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);Module[\\\"stringToUTF8\\\"]=stringToUTF8;var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};Module[\\\"stringToUTF8OnStack\\\"]=stringToUTF8OnStack;var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={\\\"string\\\":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},\\\"array\\\":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\\\"string\\\"){return UTF8ToString(ret)}if(returnType===\\\"boolean\\\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func(...cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};Module[\\\"ccall\\\"]=ccall;var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\\\"number\\\"||type===\\\"boolean\\\");var numericRet=returnType!==\\\"string\\\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};Module[\\\"cwrap\\\"]=cwrap;var FS_unlink=path=>FS.unlink(path);Module[\\\"FS_unlink\\\"]=FS_unlink;FS.createPreloadedFile=FS_createPreloadedFile;FS.staticInit();Module[\\\"FS_createPath\\\"]=FS.createPath;Module[\\\"FS_createDataFile\\\"]=FS.createDataFile;Module[\\\"FS_createPreloadedFile\\\"]=FS.createPreloadedFile;Module[\\\"FS_unlink\\\"]=FS.unlink;Module[\\\"FS_createLazyFile\\\"]=FS.createLazyFile;Module[\\\"FS_createDevice\\\"]=FS.createDevice;var wasmImports={c:___syscall_fcntl64,g:___syscall_ioctl,h:___syscall_openat,j:__emscripten_get_now_is_monotonic,k:__mmap_js,l:__munmap_js,a:_abort,d:_emscripten_date_now,i:_emscripten_get_now,s:_emscripten_memcpy_js,p:_emscripten_resize_heap,q:_environ_get,r:_environ_sizes_get,b:_fd_close,f:_fd_read,m:_fd_seek,e:_fd_write,n:_getentropy,o:_strftime_l};var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports[\\\"u\\\"])();var _wllama_malloc=Module[\\\"_wllama_malloc\\\"]=(a0,a1)=>(_wllama_malloc=Module[\\\"_wllama_malloc\\\"]=wasmExports[\\\"v\\\"])(a0,a1);var _wllama_start=Module[\\\"_wllama_start\\\"]=()=>(_wllama_start=Module[\\\"_wllama_start\\\"]=wasmExports[\\\"w\\\"])();var _wllama_action=Module[\\\"_wllama_action\\\"]=(a0,a1)=>(_wllama_action=Module[\\\"_wllama_action\\\"]=wasmExports[\\\"x\\\"])(a0,a1);var _wllama_exit=Module[\\\"_wllama_exit\\\"]=()=>(_wllama_exit=Module[\\\"_wllama_exit\\\"]=wasmExports[\\\"y\\\"])();var _wllama_debug=Module[\\\"_wllama_debug\\\"]=()=>(_wllama_debug=Module[\\\"_wllama_debug\\\"]=wasmExports[\\\"z\\\"])();var _main=Module[\\\"_main\\\"]=(a0,a1)=>(_main=Module[\\\"_main\\\"]=wasmExports[\\\"A\\\"])(a0,a1);var _emscripten_builtin_memalign=(a0,a1)=>(_emscripten_builtin_memalign=wasmExports[\\\"C\\\"])(a0,a1);var ___trap=()=>(___trap=wasmExports[\\\"D\\\"])();var setTempRet0=a0=>(setTempRet0=wasmExports[\\\"E\\\"])(a0);var stackSave=()=>(stackSave=wasmExports[\\\"F\\\"])();var stackRestore=a0=>(stackRestore=wasmExports[\\\"G\\\"])(a0);var stackAlloc=a0=>(stackAlloc=wasmExports[\\\"H\\\"])(a0);var dynCall_jiji=Module[\\\"dynCall_jiji\\\"]=(a0,a1,a2,a3,a4)=>(dynCall_jiji=Module[\\\"dynCall_jiji\\\"]=wasmExports[\\\"I\\\"])(a0,a1,a2,a3,a4);var dynCall_viij=Module[\\\"dynCall_viij\\\"]=(a0,a1,a2,a3,a4)=>(dynCall_viij=Module[\\\"dynCall_viij\\\"]=wasmExports[\\\"J\\\"])(a0,a1,a2,a3,a4);var dynCall_viijii=Module[\\\"dynCall_viijii\\\"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_viijii=Module[\\\"dynCall_viijii\\\"]=wasmExports[\\\"K\\\"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_iiiiij=Module[\\\"dynCall_iiiiij\\\"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_iiiiij=Module[\\\"dynCall_iiiiij\\\"]=wasmExports[\\\"L\\\"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_iiiiijj=Module[\\\"dynCall_iiiiijj\\\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8)=>(dynCall_iiiiijj=Module[\\\"dynCall_iiiiijj\\\"]=wasmExports[\\\"M\\\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8);var dynCall_iiiiiijj=Module[\\\"dynCall_iiiiiijj\\\"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)=>(dynCall_iiiiiijj=Module[\\\"dynCall_iiiiiijj\\\"]=wasmExports[\\\"N\\\"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);function applySignatureConversions(wasmExports){wasmExports=Object.assign({},wasmExports);var makeWrapper_ppp=f=>(a0,a1)=>f(a0,a1)>>>0;var makeWrapper_p=f=>()=>f()>>>0;var makeWrapper_pp=f=>a0=>f(a0)>>>0;wasmExports[\\\"C\\\"]=makeWrapper_ppp(wasmExports[\\\"C\\\"]);wasmExports[\\\"F\\\"]=makeWrapper_p(wasmExports[\\\"F\\\"]);wasmExports[\\\"H\\\"]=makeWrapper_pp(wasmExports[\\\"H\\\"]);return wasmExports}Module[\\\"addRunDependency\\\"]=addRunDependency;Module[\\\"removeRunDependency\\\"]=removeRunDependency;Module[\\\"FS_createPath\\\"]=FS.createPath;Module[\\\"FS_createLazyFile\\\"]=FS.createLazyFile;Module[\\\"FS_createDevice\\\"]=FS.createDevice;Module[\\\"ccall\\\"]=ccall;Module[\\\"cwrap\\\"]=cwrap;Module[\\\"FS_createPreloadedFile\\\"]=FS.createPreloadedFile;Module[\\\"FS_createDataFile\\\"]=FS.createDataFile;Module[\\\"FS_unlink\\\"]=FS.unlink;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\\\"calledRun\\\"]=true;if(ABORT)return;initRuntime();preMain();if(Module[\\\"onRuntimeInitialized\\\"])Module[\\\"onRuntimeInitialized\\\"]();if(shouldRunNow)callMain();postRun()}if(Module[\\\"setStatus\\\"]){Module[\\\"setStatus\\\"](\\\"Running...\\\");setTimeout(function(){setTimeout(function(){Module[\\\"setStatus\\\"](\\\"\\\")},1);doRun()},1)}else{doRun()}}if(Module[\\\"preInit\\\"]){if(typeof Module[\\\"preInit\\\"]==\\\"function\\\")Module[\\\"preInit\\\"]=[Module[\\\"preInit\\\"]];while(Module[\\\"preInit\\\"].length>0){Module[\\\"preInit\\\"].pop()()}}var shouldRunNow=true;if(Module[\\\"noInitialRun\\\"])shouldRunNow=false;run();\\n\";\n//# sourceMappingURL=generated.js.map\n\n//# sourceURL=webpack://victoryang00.github.io/./node_modules/@wllama/wllama/esm/workers-code/generated.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./gpt/main.ts");
/******/ 	
/******/ })()
;